
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: github.com/container-storage-interface/spec/csi.proto

package csi

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	descriptor "github.com/golang/protobuf/protoc-gen-go/descriptor"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	wrappers "github.com/golang/protobuf/ptypes/wrappers"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type PluginCapability_Service_Type int32

const (
	PluginCapability_Service_UNKNOWN PluginCapability_Service_Type = 0
	// CONTROLLER_SERVICE indicates that the Plugin provides RPCs for
	// the ControllerService. Plugins SHOULD provide this capability.
	// In rare cases certain plugins MAY wish to omit the
	// ControllerService entirely from their implementation, but such
	// SHOULD NOT be the common case.
	// The presence of this capability determines whether the CO will
	// attempt to invoke the REQUIRED ControllerService RPCs, as well
	// as specific RPCs as indicated by ControllerGetCapabilities.
	PluginCapability_Service_CONTROLLER_SERVICE PluginCapability_Service_Type = 1
	// VOLUME_ACCESSIBILITY_CONSTRAINTS indicates that the volumes for
	// this plugin MAY NOT be equally accessible by all nodes in the
	// cluster. The CO MUST use the topology information returned by
	// CreateVolumeRequest along with the topology information
	// returned by NodeGetInfo to ensure that a given volume is
	// accessible from a given node when scheduling workloads.
	PluginCapability_Service_VOLUME_ACCESSIBILITY_CONSTRAINTS PluginCapability_Service_Type = 2
	// GROUP_CONTROLLER_SERVICE indicates that the Plugin provides
	// RPCs for operating on groups of volumes. Plugins MAY provide
	// this capability.
	// The presence of this capability determines whether the CO will
	// attempt to invoke the REQUIRED GroupController service RPCs, as
	// well as specific RPCs as indicated by
	// GroupControllerGetCapabilities.
	PluginCapability_Service_GROUP_CONTROLLER_SERVICE PluginCapability_Service_Type = 3
)

var PluginCapability_Service_Type_name = map[int32]string{
	0: "UNKNOWN",
	1: "CONTROLLER_SERVICE",
	2: "VOLUME_ACCESSIBILITY_CONSTRAINTS",
	3: "GROUP_CONTROLLER_SERVICE",
}

var PluginCapability_Service_Type_value = map[string]int32{
	"UNKNOWN":                          0,
	"CONTROLLER_SERVICE":               1,
	"VOLUME_ACCESSIBILITY_CONSTRAINTS": 2,
	"GROUP_CONTROLLER_SERVICE":         3,
}

func (x PluginCapability_Service_Type) String() string {
	return proto.EnumName(PluginCapability_Service_Type_name, int32(x))
}

func (PluginCapability_Service_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{4, 0, 0}
}

type PluginCapability_VolumeExpansion_Type int32

const (
	PluginCapability_VolumeExpansion_UNKNOWN PluginCapability_VolumeExpansion_Type = 0
	// ONLINE indicates that volumes may be expanded when published to
	// a node. When a Plugin implements this capability it MUST
	// implement either the EXPAND_VOLUME controller capability or the
	// EXPAND_VOLUME node capability or both. When a plugin supports
	// ONLINE volume expansion and also has the EXPAND_VOLUME
	// controller capability then the plugin MUST support expansion of
	// volumes currently published and available on a node. When a
	// plugin supports ONLINE volume expansion and also has the
	// EXPAND_VOLUME node capability then the plugin MAY support
	// expansion of node-published volume via NodeExpandVolume.
	//
	// Example 1: Given a shared filesystem volume (e.g. GlusterFs),
	//
	//	the Plugin may set the ONLINE volume expansion capability and
	//	implement ControllerExpandVolume but not NodeExpandVolume.
	//
	// Example 2: Given a block storage volume type (e.g. EBS), the
	//
	//	Plugin may set the ONLINE volume expansion capability and
	//	implement both ControllerExpandVolume and NodeExpandVolume.
	//
	// Example 3: Given a Plugin that supports volume expansion only
	//
	//	upon a node, the Plugin may set the ONLINE volume
	//	expansion capability and implement NodeExpandVolume but not
	//	ControllerExpandVolume.
	PluginCapability_VolumeExpansion_ONLINE PluginCapability_VolumeExpansion_Type = 1
	// OFFLINE indicates that volumes currently published and
	// available on a node SHALL NOT be expanded via
	// ControllerExpandVolume. When a plugin supports OFFLINE volume
	// expansion it MUST implement either the EXPAND_VOLUME controller
	// capability or both the EXPAND_VOLUME controller capability and
	// the EXPAND_VOLUME node capability.
	//
	// Example 1: Given a block storage volume type (e.g. Azure Disk)
	//
	//	that does not support expansion of "node-attached" (i.e.
	//	controller-published) volumes, the Plugin may indicate
	//	OFFLINE volume expansion support and implement both
	//	ControllerExpandVolume and NodeExpandVolume.
	PluginCapability_VolumeExpansion_OFFLINE PluginCapability_VolumeExpansion_Type = 2
)

var PluginCapability_VolumeExpansion_Type_name = map[int32]string{
	0: "UNKNOWN",
	1: "ONLINE",
	2: "OFFLINE",
}

var PluginCapability_VolumeExpansion_Type_value = map[string]int32{
	"UNKNOWN": 0,
	"ONLINE":  1,
	"OFFLINE": 2,
}

func (x PluginCapability_VolumeExpansion_Type) String() string {
	return proto.EnumName(PluginCapability_VolumeExpansion_Type_name, int32(x))
}

func (PluginCapability_VolumeExpansion_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{4, 1, 0}
}

type VolumeCapability_AccessMode_Mode int32

const (
	VolumeCapability_AccessMode_UNKNOWN VolumeCapability_AccessMode_Mode = 0
	// Can only be published once as read/write on a single node, at
	// any given time.
	VolumeCapability_AccessMode_SINGLE_NODE_WRITER VolumeCapability_AccessMode_Mode = 1
	// Can only be published once as readonly on a single node, at
	// any given time.
	VolumeCapability_AccessMode_SINGLE_NODE_READER_ONLY VolumeCapability_AccessMode_Mode = 2
	// Can be published as readonly at multiple nodes simultaneously.
	VolumeCapability_AccessMode_MULTI_NODE_READER_ONLY VolumeCapability_AccessMode_Mode = 3
	// Can be published at multiple nodes simultaneously. Only one of
	// the node can be used as read/write. The rest will be readonly.
	VolumeCapability_AccessMode_MULTI_NODE_SINGLE_WRITER VolumeCapability_AccessMode_Mode = 4
	// Can be published as read/write at multiple nodes
	// simultaneously.
	VolumeCapability_AccessMode_MULTI_NODE_MULTI_WRITER VolumeCapability_AccessMode_Mode = 5
	// Can only be published once as read/write at a single workload
	// on a single node, at any given time. SHOULD be used instead of
	// SINGLE_NODE_WRITER for COs using the experimental
	// SINGLE_NODE_MULTI_WRITER capability.
	VolumeCapability_AccessMode_SINGLE_NODE_SINGLE_WRITER VolumeCapability_AccessMode_Mode = 6
	// Can be published as read/write at multiple workloads on a
	// single node simultaneously. SHOULD be used instead of
	// SINGLE_NODE_WRITER for COs using the experimental
	// SINGLE_NODE_MULTI_WRITER capability.
	VolumeCapability_AccessMode_SINGLE_NODE_MULTI_WRITER VolumeCapability_AccessMode_Mode = 7
)

var VolumeCapability_AccessMode_Mode_name = map[int32]string{
	0: "UNKNOWN",
	1: "SINGLE_NODE_WRITER",
	2: "SINGLE_NODE_READER_ONLY",
	3: "MULTI_NODE_READER_ONLY",
	4: "MULTI_NODE_SINGLE_WRITER",
	5: "MULTI_NODE_MULTI_WRITER",
	6: "SINGLE_NODE_SINGLE_WRITER",
	7: "SINGLE_NODE_MULTI_WRITER",
}

var VolumeCapability_AccessMode_Mode_value = map[string]int32{
	"UNKNOWN":                   0,
	"SINGLE_NODE_WRITER":        1,
	"SINGLE_NODE_READER_ONLY":   2,
	"MULTI_NODE_READER_ONLY":    3,
	"MULTI_NODE_SINGLE_WRITER":  4,
	"MULTI_NODE_MULTI_WRITER":   5,
	"SINGLE_NODE_SINGLE_WRITER": 6,
	"SINGLE_NODE_MULTI_WRITER":  7,
}

func (x VolumeCapability_AccessMode_Mode) String() string {
	return proto.EnumName(VolumeCapability_AccessMode_Mode_name, int32(x))
}

func (VolumeCapability_AccessMode_Mode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{10, 2, 0}
}

type ControllerServiceCapability_RPC_Type int32

const (
	ControllerServiceCapability_RPC_UNKNOWN                  ControllerServiceCapability_RPC_Type = 0
	ControllerServiceCapability_RPC_CREATE_DELETE_VOLUME     ControllerServiceCapability_RPC_Type = 1
	ControllerServiceCapability_RPC_PUBLISH_UNPUBLISH_VOLUME ControllerServiceCapability_RPC_Type = 2
	ControllerServiceCapability_RPC_LIST_VOLUMES             ControllerServiceCapability_RPC_Type = 3
	ControllerServiceCapability_RPC_GET_CAPACITY             ControllerServiceCapability_RPC_Type = 4
	// Currently the only way to consume a snapshot is to create
	// a volume from it. Therefore plugins supporting
	// CREATE_DELETE_SNAPSHOT MUST support creating volume from
	// snapshot.
	ControllerServiceCapability_RPC_CREATE_DELETE_SNAPSHOT ControllerServiceCapability_RPC_Type = 5
	ControllerServiceCapability_RPC_LIST_SNAPSHOTS         ControllerServiceCapability_RPC_Type = 6
	// Plugins supporting volume cloning at the storage level MAY
	// report this capability. The source volume MUST be managed by
	// the same plugin. Not all volume sources and parameters
	// combinations MAY work.
	ControllerServiceCapability_RPC_CLONE_VOLUME ControllerServiceCapability_RPC_Type = 7
	// Indicates the SP supports ControllerPublishVolume.readonly
	// field.
	ControllerServiceCapability_RPC_PUBLISH_READONLY ControllerServiceCapability_RPC_Type = 8
	// See VolumeExpansion for details.
	ControllerServiceCapability_RPC_EXPAND_VOLUME ControllerServiceCapability_RPC_Type = 9
	// Indicates the SP supports the
	// ListVolumesResponse.entry.published_node_ids field and the
	// ControllerGetVolumeResponse.published_node_ids field.
	// The SP MUST also support PUBLISH_UNPUBLISH_VOLUME.
	ControllerServiceCapability_RPC_LIST_VOLUMES_PUBLISHED_NODES ControllerServiceCapability_RPC_Type = 10
	// Indicates that the Controller service can report volume
	// conditions.
	// An SP MAY implement `VolumeCondition` in only the Controller
	// Plugin, only the Node Plugin, or both.
	// If `VolumeCondition` is implemented in both the Controller and
	// Node Plugins, it SHALL report from different perspectives.
	// If for some reason Controller and Node Plugins report
	// misaligned volume conditions, CO SHALL assume the worst case
	// is the truth.
	// Note that, for alpha, `VolumeCondition` is intended be
	// informative for humans only, not for automation.
	ControllerServiceCapability_RPC_VOLUME_CONDITION ControllerServiceCapability_RPC_Type = 11
	// Indicates the SP supports the ControllerGetVolume RPC.
	// This enables COs to, for example, fetch per volume
	// condition after a volume is provisioned.
	ControllerServiceCapability_RPC_GET_VOLUME ControllerServiceCapability_RPC_Type = 12
	// Indicates the SP supports the SINGLE_NODE_SINGLE_WRITER and/or
	// SINGLE_NODE_MULTI_WRITER access modes.
	// These access modes are intended to replace the
	// SINGLE_NODE_WRITER access mode to clarify the number of writers
	// for a volume on a single node. Plugins MUST accept and allow
	// use of the SINGLE_NODE_WRITER access mode when either
	// SINGLE_NODE_SINGLE_WRITER and/or SINGLE_NODE_MULTI_WRITER are
	// supported, in order to permit older COs to continue working.
	ControllerServiceCapability_RPC_SINGLE_NODE_MULTI_WRITER ControllerServiceCapability_RPC_Type = 13
)

var ControllerServiceCapability_RPC_Type_name = map[int32]string{
	0:  "UNKNOWN",
	1:  "CREATE_DELETE_VOLUME",
	2:  "PUBLISH_UNPUBLISH_VOLUME",
	3:  "LIST_VOLUMES",
	4:  "GET_CAPACITY",
	5:  "CREATE_DELETE_SNAPSHOT",
	6:  "LIST_SNAPSHOTS",
	7:  "CLONE_VOLUME",
	8:  "PUBLISH_READONLY",
	9:  "EXPAND_VOLUME",
	10: "LIST_VOLUMES_PUBLISHED_NODES",
	11: "VOLUME_CONDITION",
	12: "GET_VOLUME",
	13: "SINGLE_NODE_MULTI_WRITER",
}

var ControllerServiceCapability_RPC_Type_value = map[string]int32{
	"UNKNOWN":                      0,
	"CREATE_DELETE_VOLUME":         1,
	"PUBLISH_UNPUBLISH_VOLUME":     2,
	"LIST_VOLUMES":                 3,
	"GET_CAPACITY":                 4,
	"CREATE_DELETE_SNAPSHOT":       5,
	"LIST_SNAPSHOTS":               6,
	"CLONE_VOLUME":                 7,
	"PUBLISH_READONLY":             8,
	"EXPAND_VOLUME":                9,
	"LIST_VOLUMES_PUBLISHED_NODES": 10,
	"VOLUME_CONDITION":             11,
	"GET_VOLUME":                   12,
	"SINGLE_NODE_MULTI_WRITER":     13,
}

func (x ControllerServiceCapability_RPC_Type) String() string {
	return proto.EnumName(ControllerServiceCapability_RPC_Type_name, int32(x))
}

func (ControllerServiceCapability_RPC_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{31, 0, 0}
}

type VolumeUsage_Unit int32

const (
	VolumeUsage_UNKNOWN VolumeUsage_Unit = 0
	VolumeUsage_BYTES   VolumeUsage_Unit = 1
	VolumeUsage_INODES  VolumeUsage_Unit = 2
)

var VolumeUsage_Unit_name = map[int32]string{
	0: "UNKNOWN",
	1: "BYTES",
	2: "INODES",
}

var VolumeUsage_Unit_value = map[string]int32{
	"UNKNOWN": 0,
	"BYTES":   1,
	"INODES":  2,
}

func (x VolumeUsage_Unit) String() string {
	return proto.EnumName(VolumeUsage_Unit_name, int32(x))
}

func (VolumeUsage_Unit) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{51, 0}
}

type NodeServiceCapability_RPC_Type int32

const (
	NodeServiceCapability_RPC_UNKNOWN              NodeServiceCapability_RPC_Type = 0
	NodeServiceCapability_RPC_STAGE_UNSTAGE_VOLUME NodeServiceCapability_RPC_Type = 1
	// If Plugin implements GET_VOLUME_STATS capability
	// then it MUST implement NodeGetVolumeStats RPC
	// call for fetching volume statistics.
	NodeServiceCapability_RPC_GET_VOLUME_STATS NodeServiceCapability_RPC_Type = 2
	// See VolumeExpansion for details.
	NodeServiceCapability_RPC_EXPAND_VOLUME NodeServiceCapability_RPC_Type = 3
	// Indicates that the Node service can report volume conditions.
	// An SP MAY implement `VolumeCondition` in only the Node
	// Plugin, only the Controller Plugin, or both.
	// If `VolumeCondition` is implemented in both the Node and
	// Controller Plugins, it SHALL report from different
	// perspectives.
	// If for some reason Node and Controller Plugins report
	// misaligned volume conditions, CO SHALL assume the worst case
	// is the truth.
	// Note that, for alpha, `VolumeCondition` is intended to be
	// informative for humans only, not for automation.
	NodeServiceCapability_RPC_VOLUME_CONDITION NodeServiceCapability_RPC_Type = 4
	// Indicates the SP supports the SINGLE_NODE_SINGLE_WRITER and/or
	// SINGLE_NODE_MULTI_WRITER access modes.
	// These access modes are intended to replace the
	// SINGLE_NODE_WRITER access mode to clarify the number of writers
	// for a volume on a single node. Plugins MUST accept and allow
	// use of the SINGLE_NODE_WRITER access mode (subject to the
	// processing rules for NodePublishVolume), when either
	// SINGLE_NODE_SINGLE_WRITER and/or SINGLE_NODE_MULTI_WRITER are
	// supported, in order to permit older COs to continue working.
	NodeServiceCapability_RPC_SINGLE_NODE_MULTI_WRITER NodeServiceCapability_RPC_Type = 5
	// Indicates that Node service supports mounting volumes
	// with provided volume group identifier during node stage
	// or node publish RPC calls.
	NodeServiceCapability_RPC_VOLUME_MOUNT_GROUP NodeServiceCapability_RPC_Type = 6
)

var NodeServiceCapability_RPC_Type_name = map[int32]string{
	0: "UNKNOWN",
	1: "STAGE_UNSTAGE_VOLUME",
	2: "GET_VOLUME_STATS",
	3: "EXPAND_VOLUME",
	4: "VOLUME_CONDITION",
	5: "SINGLE_NODE_MULTI_WRITER",
	6: "VOLUME_MOUNT_GROUP",
}

var NodeServiceCapability_RPC_Type_value = map[string]int32{
	"UNKNOWN":                  0,
	"STAGE_UNSTAGE_VOLUME":     1,
	"GET_VOLUME_STATS":         2,
	"EXPAND_VOLUME":            3,
	"VOLUME_CONDITION":         4,
	"SINGLE_NODE_MULTI_WRITER": 5,
	"VOLUME_MOUNT_GROUP":       6,
}

func (x NodeServiceCapability_RPC_Type) String() string {
	return proto.EnumName(NodeServiceCapability_RPC_Type_name, int32(x))
}

func (NodeServiceCapability_RPC_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{55, 0, 0}
}

type GroupControllerServiceCapability_RPC_Type int32

const (
	GroupControllerServiceCapability_RPC_UNKNOWN GroupControllerServiceCapability_RPC_Type = 0
	// Indicates that the group controller plugin supports
	// creating, deleting, and getting details of a volume
	// group snapshot.
	GroupControllerServiceCapability_RPC_CREATE_DELETE_GET_VOLUME_GROUP_SNAPSHOT GroupControllerServiceCapability_RPC_Type = 1
)

var GroupControllerServiceCapability_RPC_Type_name = map[int32]string{
	0: "UNKNOWN",
	1: "CREATE_DELETE_GET_VOLUME_GROUP_SNAPSHOT",
}

var GroupControllerServiceCapability_RPC_Type_value = map[string]int32{
	"UNKNOWN": 0,
	"CREATE_DELETE_GET_VOLUME_GROUP_SNAPSHOT": 1,
}

func (x GroupControllerServiceCapability_RPC_Type) String() string {
	return proto.EnumName(GroupControllerServiceCapability_RPC_Type_name, int32(x))
}

func (GroupControllerServiceCapability_RPC_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{62, 0, 0}
}

type GetPluginInfoRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetPluginInfoRequest) Reset()         { *m = GetPluginInfoRequest{} }
func (m *GetPluginInfoRequest) String() string { return proto.CompactTextString(m) }
func (*GetPluginInfoRequest) ProtoMessage()    {}
func (*GetPluginInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{0}
}

func (m *GetPluginInfoRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetPluginInfoRequest.Unmarshal(m, b)
}
func (m *GetPluginInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetPluginInfoRequest.Marshal(b, m, deterministic)
}
func (m *GetPluginInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPluginInfoRequest.Merge(m, src)
}
func (m *GetPluginInfoRequest) XXX_Size() int {
	return xxx_messageInfo_GetPluginInfoRequest.Size(m)
}
func (m *GetPluginInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPluginInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetPluginInfoRequest proto.InternalMessageInfo

type GetPluginInfoResponse struct {
	// The name MUST follow domain name notation format
	// (https://tools.ietf.org/html/rfc1035#section-2.3.1). It SHOULD
	// include the plugin's host company name and the plugin name,
	// to minimize the possibility of collisions. It MUST be 63
	// characters or less, beginning and ending with an alphanumeric
	// character ([a-z0-9A-Z]) with dashes (-), dots (.), and
	// alphanumerics between. This field is REQUIRED.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// This field is REQUIRED. Value of this field is opaque to the CO.
	VendorVersion string `protobuf:"bytes,2,opt,name=vendor_version,json=vendorVersion,proto3" json:"vendor_version,omitempty"`
	// This field is OPTIONAL. Values are opaque to the CO.
	Manifest             map[string]string `protobuf:"bytes,3,rep,name=manifest,proto3" json:"manifest,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GetPluginInfoResponse) Reset()         { *m = GetPluginInfoResponse{} }
func (m *GetPluginInfoResponse) String() string { return proto.CompactTextString(m) }
func (*GetPluginInfoResponse) ProtoMessage()    {}
func (*GetPluginInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{1}
}

func (m *GetPluginInfoResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetPluginInfoResponse.Unmarshal(m, b)
}
func (m *GetPluginInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetPluginInfoResponse.Marshal(b, m, deterministic)
}
func (m *GetPluginInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPluginInfoResponse.Merge(m, src)
}
func (m *GetPluginInfoResponse) XXX_Size() int {
	return xxx_messageInfo_GetPluginInfoResponse.Size(m)
}
func (m *GetPluginInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPluginInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetPluginInfoResponse proto.InternalMessageInfo

func (m *GetPluginInfoResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetPluginInfoResponse) GetVendorVersion() string {
	if m != nil {
		return m.VendorVersion
	}
	return ""
}

func (m *GetPluginInfoResponse) GetManifest() map[string]string {
	if m != nil {
		return m.Manifest
	}
	return nil
}

type GetPluginCapabilitiesRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetPluginCapabilitiesRequest) Reset()         { *m = GetPluginCapabilitiesRequest{} }
func (m *GetPluginCapabilitiesRequest) String() string { return proto.CompactTextString(m) }
func (*GetPluginCapabilitiesRequest) ProtoMessage()    {}
func (*GetPluginCapabilitiesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{2}
}

func (m *GetPluginCapabilitiesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetPluginCapabilitiesRequest.Unmarshal(m, b)
}
func (m *GetPluginCapabilitiesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetPluginCapabilitiesRequest.Marshal(b, m, deterministic)
}
func (m *GetPluginCapabilitiesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPluginCapabilitiesRequest.Merge(m, src)
}
func (m *GetPluginCapabilitiesRequest) XXX_Size() int {
	return xxx_messageInfo_GetPluginCapabilitiesRequest.Size(m)
}
func (m *GetPluginCapabilitiesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPluginCapabilitiesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetPluginCapabilitiesRequest proto.InternalMessageInfo

type GetPluginCapabilitiesResponse struct {
	// All the capabilities that the controller service supports. This
	// field is OPTIONAL.
	Capabilities         []*PluginCapability `protobuf:"bytes,1,rep,name=capabilities,proto3" json:"capabilities,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *GetPluginCapabilitiesResponse) Reset()         { *m = GetPluginCapabilitiesResponse{} }
func (m *GetPluginCapabilitiesResponse) String() string { return proto.CompactTextString(m) }
func (*GetPluginCapabilitiesResponse) ProtoMessage()    {}
func (*GetPluginCapabilitiesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{3}
}

func (m *GetPluginCapabilitiesResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetPluginCapabilitiesResponse.Unmarshal(m, b)
}
func (m *GetPluginCapabilitiesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetPluginCapabilitiesResponse.Marshal(b, m, deterministic)
}
func (m *GetPluginCapabilitiesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPluginCapabilitiesResponse.Merge(m, src)
}
func (m *GetPluginCapabilitiesResponse) XXX_Size() int {
	return xxx_messageInfo_GetPluginCapabilitiesResponse.Size(m)
}
func (m *GetPluginCapabilitiesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPluginCapabilitiesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetPluginCapabilitiesResponse proto.InternalMessageInfo

func (m *GetPluginCapabilitiesResponse) GetCapabilities() []*PluginCapability {
	if m != nil {
		return m.Capabilities
	}
	return nil
}

// Specifies a capability of the plugin.
type PluginCapability struct {
	// Types that are valid to be assigned to Type:
	//
	//	*PluginCapability_Service_
	//	*PluginCapability_VolumeExpansion_
	Type                 isPluginCapability_Type `protobuf_oneof:"type"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *PluginCapability) Reset()         { *m = PluginCapability{} }
func (m *PluginCapability) String() string { return proto.CompactTextString(m) }
func (*PluginCapability) ProtoMessage()    {}
func (*PluginCapability) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{4}
}

func (m *PluginCapability) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PluginCapability.Unmarshal(m, b)
}
func (m *PluginCapability) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PluginCapability.Marshal(b, m, deterministic)
}
func (m *PluginCapability) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginCapability.Merge(m, src)
}
func (m *PluginCapability) XXX_Size() int {
	return xxx_messageInfo_PluginCapability.Size(m)
}
func (m *PluginCapability) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginCapability.DiscardUnknown(m)
}

var xxx_messageInfo_PluginCapability proto.InternalMessageInfo

type isPluginCapability_Type interface {
	isPluginCapability_Type()
}

type PluginCapability_Service_ struct {
	Service *PluginCapability_Service `protobuf:"bytes,1,opt,name=service,proto3,oneof"`
}

type PluginCapability_VolumeExpansion_ struct {
	VolumeExpansion *PluginCapability_VolumeExpansion `protobuf:"bytes,2,opt,name=volume_expansion,json=volumeExpansion,proto3,oneof"`
}

func (*PluginCapability_Service_) isPluginCapability_Type() {}

func (*PluginCapability_VolumeExpansion_) isPluginCapability_Type() {}

func (m *PluginCapability) GetType() isPluginCapability_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *PluginCapability) GetService() *PluginCapability_Service {
	if x, ok := m.GetType().(*PluginCapability_Service_); ok {
		return x.Service
	}
	return nil
}

func (m *PluginCapability) GetVolumeExpansion() *PluginCapability_VolumeExpansion {
	if x, ok := m.GetType().(*PluginCapability_VolumeExpansion_); ok {
		return x.VolumeExpansion
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PluginCapability) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PluginCapability_Service_)(nil),
		(*PluginCapability_VolumeExpansion_)(nil),
	}
}

type PluginCapability_Service struct {
	Type                 PluginCapability_Service_Type `protobuf:"varint,1,opt,name=type,proto3,enum=csi.v1.PluginCapability_Service_Type" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *PluginCapability_Service) Reset()         { *m = PluginCapability_Service{} }
func (m *PluginCapability_Service) String() string { return proto.CompactTextString(m) }
func (*PluginCapability_Service) ProtoMessage()    {}
func (*PluginCapability_Service) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{4, 0}
}

func (m *PluginCapability_Service) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PluginCapability_Service.Unmarshal(m, b)
}
func (m *PluginCapability_Service) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PluginCapability_Service.Marshal(b, m, deterministic)
}
func (m *PluginCapability_Service) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginCapability_Service.Merge(m, src)
}
func (m *PluginCapability_Service) XXX_Size() int {
	return xxx_messageInfo_PluginCapability_Service.Size(m)
}
func (m *PluginCapability_Service) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginCapability_Service.DiscardUnknown(m)
}

var xxx_messageInfo_PluginCapability_Service proto.InternalMessageInfo

func (m *PluginCapability_Service) GetType() PluginCapability_Service_Type {
	if m != nil {
		return m.Type
	}
	return PluginCapability_Service_UNKNOWN
}

type PluginCapability_VolumeExpansion struct {
	Type                 PluginCapability_VolumeExpansion_Type `protobuf:"varint,1,opt,name=type,proto3,enum=csi.v1.PluginCapability_VolumeExpansion_Type" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                              `json:"-"`
	XXX_unrecognized     []byte                                `json:"-"`
	XXX_sizecache        int32                                 `json:"-"`
}

func (m *PluginCapability_VolumeExpansion) Reset()         { *m = PluginCapability_VolumeExpansion{} }
func (m *PluginCapability_VolumeExpansion) String() string { return proto.CompactTextString(m) }
func (*PluginCapability_VolumeExpansion) ProtoMessage()    {}
func (*PluginCapability_VolumeExpansion) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{4, 1}
}

func (m *PluginCapability_VolumeExpansion) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PluginCapability_VolumeExpansion.Unmarshal(m, b)
}
func (m *PluginCapability_VolumeExpansion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PluginCapability_VolumeExpansion.Marshal(b, m, deterministic)
}
func (m *PluginCapability_VolumeExpansion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginCapability_VolumeExpansion.Merge(m, src)
}
func (m *PluginCapability_VolumeExpansion) XXX_Size() int {
	return xxx_messageInfo_PluginCapability_VolumeExpansion.Size(m)
}
func (m *PluginCapability_VolumeExpansion) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginCapability_VolumeExpansion.DiscardUnknown(m)
}

var xxx_messageInfo_PluginCapability_VolumeExpansion proto.InternalMessageInfo

func (m *PluginCapability_VolumeExpansion) GetType() PluginCapability_VolumeExpansion_Type {
	if m != nil {
		return m.Type
	}
	return PluginCapability_VolumeExpansion_UNKNOWN
}

type ProbeRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProbeRequest) Reset()         { *m = ProbeRequest{} }
func (m *ProbeRequest) String() string { return proto.CompactTextString(m) }
func (*ProbeRequest) ProtoMessage()    {}
func (*ProbeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{5}
}

func (m *ProbeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ProbeRequest.Unmarshal(m, b)
}
func (m *ProbeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ProbeRequest.Marshal(b, m, deterministic)
}
func (m *ProbeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProbeRequest.Merge(m, src)
}
func (m *ProbeRequest) XXX_Size() int {
	return xxx_messageInfo_ProbeRequest.Size(m)
}
func (m *ProbeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ProbeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ProbeRequest proto.InternalMessageInfo

type ProbeResponse struct {
	// Readiness allows a plugin to report its initialization status back
	// to the CO. Initialization for some plugins MAY be time consuming
	// and it is important for a CO to distinguish between the following
	// cases:
	//
	//  1. The plugin is in an unhealthy state and MAY need restarting. In
	//     this case a gRPC error code SHALL be returned.
	//  2. The plugin is still initializing, but is otherwise perfectly
	//     healthy. In this case a successful response SHALL be returned
	//     with a readiness value of `false`. Calls to the plugin's
	//     Controller and/or Node services MAY fail due to an incomplete
	//     initialization state.
	//  3. The plugin has finished initializing and is ready to service
	//     calls to its Controller and/or Node services. A successful
	//     response is returned with a readiness value of `true`.
	//
	// This field is OPTIONAL. If not present, the caller SHALL assume
	// that the plugin is in a ready state and is accepting calls to its
	// Controller and/or Node services (according to the plugin's reported
	// capabilities).
	Ready                *wrappers.BoolValue `protobuf:"bytes,1,opt,name=ready,proto3" json:"ready,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *ProbeResponse) Reset()         { *m = ProbeResponse{} }
func (m *ProbeResponse) String() string { return proto.CompactTextString(m) }
func (*ProbeResponse) ProtoMessage()    {}
func (*ProbeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{6}
}

func (m *ProbeResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ProbeResponse.Unmarshal(m, b)
}
func (m *ProbeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ProbeResponse.Marshal(b, m, deterministic)
}
func (m *ProbeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProbeResponse.Merge(m, src)
}
func (m *ProbeResponse) XXX_Size() int {
	return xxx_messageInfo_ProbeResponse.Size(m)
}
func (m *ProbeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ProbeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ProbeResponse proto.InternalMessageInfo

func (m *ProbeResponse) GetReady() *wrappers.BoolValue {
	if m != nil {
		return m.Ready
	}
	return nil
}

type CreateVolumeRequest struct {
	// The suggested name for the storage space. This field is REQUIRED.
	// It serves two purposes:
	//  1. Idempotency - This name is generated by the CO to achieve
	//     idempotency.  The Plugin SHOULD ensure that multiple
	//     `CreateVolume` calls for the same name do not result in more
	//     than one piece of storage provisioned corresponding to that
	//     name. If a Plugin is unable to enforce idempotency, the CO's
	//     error recovery logic could result in multiple (unused) volumes
	//     being provisioned.
	//     In the case of error, the CO MUST handle the gRPC error codes
	//     per the recovery behavior defined in the "CreateVolume Errors"
	//     section below.
	//     The CO is responsible for cleaning up volumes it provisioned
	//     that it no longer needs. If the CO is uncertain whether a volume
	//     was provisioned or not when a `CreateVolume` call fails, the CO
	//     MAY call `CreateVolume` again, with the same name, to ensure the
	//     volume exists and to retrieve the volume's `volume_id` (unless
	//     otherwise prohibited by "CreateVolume Errors").
	//  2. Suggested name - Some storage systems allow callers to specify
	//     an identifier by which to refer to the newly provisioned
	//     storage. If a storage system supports this, it can optionally
	//     use this name as the identifier for the new volume.
	//
	// Any Unicode string that conforms to the length limit is allowed
	// except those containing the following banned characters:
	// U+0000-U+0008, U+000B, U+000C, U+000E-U+001F, U+007F-U+009F.
	// (These are control characters other than commonly used whitespace.)
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// This field is OPTIONAL. This allows the CO to specify the capacity
	// requirement of the volume to be provisioned. If not specified, the
	// Plugin MAY choose an implementation-defined capacity range. If
	// specified it MUST always be honored, even when creating volumes
	// from a source; which MAY force some backends to internally extend
	// the volume after creating it.
	CapacityRange *CapacityRange `protobuf:"bytes,2,opt,name=capacity_range,json=capacityRange,proto3" json:"capacity_range,omitempty"`
	// The capabilities that the provisioned volume MUST have. SP MUST
	// provision a volume that will satisfy ALL of the capabilities
	// specified in this list. Otherwise SP MUST return the appropriate
	// gRPC error code.
	// The Plugin MUST assume that the CO MAY use the provisioned volume
	// with ANY of the capabilities specified in this list.
	// For example, a CO MAY specify two volume capabilities: one with
	// access mode SINGLE_NODE_WRITER and another with access mode
	// MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
	// provisioned volume can be used in either mode.
	// This also enables the CO to do early validation: If ANY of the
	// specified volume capabilities are not supported by the SP, the call
	// MUST return the appropriate gRPC error code.
	// This field is REQUIRED.
	VolumeCapabilities []*VolumeCapability `protobuf:"bytes,3,rep,name=volume_capabilities,json=volumeCapabilities,proto3" json:"volume_capabilities,omitempty"`
	// Plugin specific parameters passed in as opaque key-value pairs.
	// This field is OPTIONAL. The Plugin is responsible for parsing and
	// validating these parameters. COs will treat these as opaque.
	Parameters map[string]string `protobuf:"bytes,4,rep,name=parameters,proto3" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Secrets required by plugin to complete volume creation request.
	// This field is OPTIONAL. Refer to the `Secrets Requirements`
	// section on how to use this field.
	Secrets map[string]string `protobuf:"bytes,5,rep,name=secrets,proto3" json:"secrets,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// If specified, the new volume will be pre-populated with data from
	// this source. This field is OPTIONAL.
	VolumeContentSource *VolumeContentSource `protobuf:"bytes,6,opt,name=volume_content_source,json=volumeContentSource,proto3" json:"volume_content_source,omitempty"`
	// Specifies where (regions, zones, racks, etc.) the provisioned
	// volume MUST be accessible from.
	// An SP SHALL advertise the requirements for topological
	// accessibility information in documentation. COs SHALL only specify
	// topological accessibility information supported by the SP.
	// This field is OPTIONAL.
	// This field SHALL NOT be specified unless the SP has the
	// VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
	// If this field is not specified and the SP has the
	// VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY
	// choose where the provisioned volume is accessible from.
	AccessibilityRequirements *TopologyRequirement `protobuf:"bytes,7,opt,name=accessibility_requirements,json=accessibilityRequirements,proto3" json:"accessibility_requirements,omitempty"`
	XXX_NoUnkeyedLiteral      struct{}             `json:"-"`
	XXX_unrecognized          []byte               `json:"-"`
	XXX_sizecache             int32                `json:"-"`
}

func (m *CreateVolumeRequest) Reset()         { *m = CreateVolumeRequest{} }
func (m *CreateVolumeRequest) String() string { return proto.CompactTextString(m) }
func (*CreateVolumeRequest) ProtoMessage()    {}
func (*CreateVolumeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{7}
}

func (m *CreateVolumeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CreateVolumeRequest.Unmarshal(m, b)
}
func (m *CreateVolumeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CreateVolumeRequest.Marshal(b, m, deterministic)
}
func (m *CreateVolumeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateVolumeRequest.Merge(m, src)
}
func (m *CreateVolumeRequest) XXX_Size() int {
	return xxx_messageInfo_CreateVolumeRequest.Size(m)
}
func (m *CreateVolumeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateVolumeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateVolumeRequest proto.InternalMessageInfo

func (m *CreateVolumeRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateVolumeRequest) GetCapacityRange() *CapacityRange {
	if m != nil {
		return m.CapacityRange
	}
	return nil
}

func (m *CreateVolumeRequest) GetVolumeCapabilities() []*VolumeCapability {
	if m != nil {
		return m.VolumeCapabilities
	}
	return nil
}

func (m *CreateVolumeRequest) GetParameters() map[string]string {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *CreateVolumeRequest) GetSecrets() map[string]string {
	if m != nil {
		return m.Secrets
	}
	return nil
}

func (m *CreateVolumeRequest) GetVolumeContentSource() *VolumeContentSource {
	if m != nil {
		return m.VolumeContentSource
	}
	return nil
}

func (m *CreateVolumeRequest) GetAccessibilityRequirements() *TopologyRequirement {
	if m != nil {
		return m.AccessibilityRequirements
	}
	return nil
}

// Specifies what source the volume will be created from. One of the
// type fields MUST be specified.
type VolumeContentSource struct {
	// Types that are valid to be assigned to Type:
	//
	//	*VolumeContentSource_Snapshot
	//	*VolumeContentSource_Volume
	Type                 isVolumeContentSource_Type `protobuf_oneof:"type"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *VolumeContentSource) Reset()         { *m = VolumeContentSource{} }
func (m *VolumeContentSource) String() string { return proto.CompactTextString(m) }
func (*VolumeContentSource) ProtoMessage()    {}
func (*VolumeContentSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{8}
}

func (m *VolumeContentSource) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeContentSource.Unmarshal(m, b)
}
func (m *VolumeContentSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeContentSource.Marshal(b, m, deterministic)
}
func (m *VolumeContentSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeContentSource.Merge(m, src)
}
func (m *VolumeContentSource) XXX_Size() int {
	return xxx_messageInfo_VolumeContentSource.Size(m)
}
func (m *VolumeContentSource) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeContentSource.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeContentSource proto.InternalMessageInfo

type isVolumeContentSource_Type interface {
	isVolumeContentSource_Type()
}

type VolumeContentSource_Snapshot struct {
	Snapshot *VolumeContentSource_SnapshotSource `protobuf:"bytes,1,opt,name=snapshot,proto3,oneof"`
}

type VolumeContentSource_Volume struct {
	Volume *VolumeContentSource_VolumeSource `protobuf:"bytes,2,opt,name=volume,proto3,oneof"`
}

func (*VolumeContentSource_Snapshot) isVolumeContentSource_Type() {}

func (*VolumeContentSource_Volume) isVolumeContentSource_Type() {}

func (m *VolumeContentSource) GetType() isVolumeContentSource_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *VolumeContentSource) GetSnapshot() *VolumeContentSource_SnapshotSource {
	if x, ok := m.GetType().(*VolumeContentSource_Snapshot); ok {
		return x.Snapshot
	}
	return nil
}

func (m *VolumeContentSource) GetVolume() *VolumeContentSource_VolumeSource {
	if x, ok := m.GetType().(*VolumeContentSource_Volume); ok {
		return x.Volume
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*VolumeContentSource) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*VolumeContentSource_Snapshot)(nil),
		(*VolumeContentSource_Volume)(nil),
	}
}

type VolumeContentSource_SnapshotSource struct {
	// Contains identity information for the existing source snapshot.
	// This field is REQUIRED. Plugin is REQUIRED to support creating
	// volume from snapshot if it supports the capability
	// CREATE_DELETE_SNAPSHOT.
	SnapshotId           string   `protobuf:"bytes,1,opt,name=snapshot_id,json=snapshotId,proto3" json:"snapshot_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VolumeContentSource_SnapshotSource) Reset()         { *m = VolumeContentSource_SnapshotSource{} }
func (m *VolumeContentSource_SnapshotSource) String() string { return proto.CompactTextString(m) }
func (*VolumeContentSource_SnapshotSource) ProtoMessage()    {}
func (*VolumeContentSource_SnapshotSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{8, 0}
}

func (m *VolumeContentSource_SnapshotSource) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeContentSource_SnapshotSource.Unmarshal(m, b)
}
func (m *VolumeContentSource_SnapshotSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeContentSource_SnapshotSource.Marshal(b, m, deterministic)
}
func (m *VolumeContentSource_SnapshotSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeContentSource_SnapshotSource.Merge(m, src)
}
func (m *VolumeContentSource_SnapshotSource) XXX_Size() int {
	return xxx_messageInfo_VolumeContentSource_SnapshotSource.Size(m)
}
func (m *VolumeContentSource_SnapshotSource) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeContentSource_SnapshotSource.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeContentSource_SnapshotSource proto.InternalMessageInfo

func (m *VolumeContentSource_SnapshotSource) GetSnapshotId() string {
	if m != nil {
		return m.SnapshotId
	}
	return ""
}

type VolumeContentSource_VolumeSource struct {
	// Contains identity information for the existing source volume.
	// This field is REQUIRED. Plugins reporting CLONE_VOLUME
	// capability MUST support creating a volume from another volume.
	VolumeId             string   `protobuf:"bytes,1,opt,name=volume_id,json=volumeId,proto3" json:"volume_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VolumeContentSource_VolumeSource) Reset()         { *m = VolumeContentSource_VolumeSource{} }
func (m *VolumeContentSource_VolumeSource) String() string { return proto.CompactTextString(m) }
func (*VolumeContentSource_VolumeSource) ProtoMessage()    {}
func (*VolumeContentSource_VolumeSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{8, 1}
}

func (m *VolumeContentSource_VolumeSource) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeContentSource_VolumeSource.Unmarshal(m, b)
}
func (m *VolumeContentSource_VolumeSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeContentSource_VolumeSource.Marshal(b, m, deterministic)
}
func (m *VolumeContentSource_VolumeSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeContentSource_VolumeSource.Merge(m, src)
}
func (m *VolumeContentSource_VolumeSource) XXX_Size() int {
	return xxx_messageInfo_VolumeContentSource_VolumeSource.Size(m)
}
func (m *VolumeContentSource_VolumeSource) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeContentSource_VolumeSource.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeContentSource_VolumeSource proto.InternalMessageInfo

func (m *VolumeContentSource_VolumeSource) GetVolumeId() string {
	if m != nil {
		return m.VolumeId
	}
	return ""
}

type CreateVolumeResponse struct {
	// Contains all attributes of the newly created volume that are
	// relevant to the CO along with information required by the Plugin
	// to uniquely identify the volume. This field is REQUIRED.
	Volume               *Volume  `protobuf:"bytes,1,opt,name=volume,proto3" json:"volume,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateVolumeResponse) Reset()         { *m = CreateVolumeResponse{} }
func (m *CreateVolumeResponse) String() string { return proto.CompactTextString(m) }
func (*CreateVolumeResponse) ProtoMessage()    {}
func (*CreateVolumeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{9}
}

func (m *CreateVolumeResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CreateVolumeResponse.Unmarshal(m, b)
}
func (m *CreateVolumeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CreateVolumeResponse.Marshal(b, m, deterministic)
}
func (m *CreateVolumeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateVolumeResponse.Merge(m, src)
}
func (m *CreateVolumeResponse) XXX_Size() int {
	return xxx_messageInfo_CreateVolumeResponse.Size(m)
}
func (m *CreateVolumeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateVolumeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateVolumeResponse proto.InternalMessageInfo

func (m *CreateVolumeResponse) GetVolume() *Volume {
	if m != nil {
		return m.Volume
	}
	return nil
}

// Specify a capability of a volume.
type VolumeCapability struct {
	// Specifies what API the volume will be accessed using. One of the
	// following fields MUST be specified.
	//
	// Types that are valid to be assigned to AccessType:
	//
	//	*VolumeCapability_Block
	//	*VolumeCapability_Mount
	AccessType isVolumeCapability_AccessType `protobuf_oneof:"access_type"`
	// This is a REQUIRED field.
	AccessMode           *VolumeCapability_AccessMode `protobuf:"bytes,3,opt,name=access_mode,json=accessMode,proto3" json:"access_mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *VolumeCapability) Reset()         { *m = VolumeCapability{} }
func (m *VolumeCapability) String() string { return proto.CompactTextString(m) }
func (*VolumeCapability) ProtoMessage()    {}
func (*VolumeCapability) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{10}
}

func (m *VolumeCapability) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeCapability.Unmarshal(m, b)
}
func (m *VolumeCapability) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeCapability.Marshal(b, m, deterministic)
}
func (m *VolumeCapability) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeCapability.Merge(m, src)
}
func (m *VolumeCapability) XXX_Size() int {
	return xxx_messageInfo_VolumeCapability.Size(m)
}
func (m *VolumeCapability) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeCapability.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeCapability proto.InternalMessageInfo

type isVolumeCapability_AccessType interface {
	isVolumeCapability_AccessType()
}

type VolumeCapability_Block struct {
	Block *VolumeCapability_BlockVolume `protobuf:"bytes,1,opt,name=block,proto3,oneof"`
}

type VolumeCapability_Mount struct {
	Mount *VolumeCapability_MountVolume `protobuf:"bytes,2,opt,name=mount,proto3,oneof"`
}

func (*VolumeCapability_Block) isVolumeCapability_AccessType() {}

func (*VolumeCapability_Mount) isVolumeCapability_AccessType() {}

func (m *VolumeCapability) GetAccessType() isVolumeCapability_AccessType {
	if m != nil {
		return m.AccessType
	}
	return nil
}

func (m *VolumeCapability) GetBlock() *VolumeCapability_BlockVolume {
	if x, ok := m.GetAccessType().(*VolumeCapability_Block); ok {
		return x.Block
	}
	return nil
}

func (m *VolumeCapability) GetMount() *VolumeCapability_MountVolume {
	if x, ok := m.GetAccessType().(*VolumeCapability_Mount); ok {
		return x.Mount
	}
	return nil
}

func (m *VolumeCapability) GetAccessMode() *VolumeCapability_AccessMode {
	if m != nil {
		return m.AccessMode
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*VolumeCapability) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*VolumeCapability_Block)(nil),
		(*VolumeCapability_Mount)(nil),
	}
}

// Indicate that the volume will be accessed via the block device API.
type VolumeCapability_BlockVolume struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VolumeCapability_BlockVolume) Reset()         { *m = VolumeCapability_BlockVolume{} }
func (m *VolumeCapability_BlockVolume) String() string { return proto.CompactTextString(m) }
func (*VolumeCapability_BlockVolume) ProtoMessage()    {}
func (*VolumeCapability_BlockVolume) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{10, 0}
}

func (m *VolumeCapability_BlockVolume) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeCapability_BlockVolume.Unmarshal(m, b)
}
func (m *VolumeCapability_BlockVolume) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeCapability_BlockVolume.Marshal(b, m, deterministic)
}
func (m *VolumeCapability_BlockVolume) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeCapability_BlockVolume.Merge(m, src)
}
func (m *VolumeCapability_BlockVolume) XXX_Size() int {
	return xxx_messageInfo_VolumeCapability_BlockVolume.Size(m)
}
func (m *VolumeCapability_BlockVolume) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeCapability_BlockVolume.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeCapability_BlockVolume proto.InternalMessageInfo

// Indicate that the volume will be accessed via the filesystem API.
type VolumeCapability_MountVolume struct {
	// The filesystem type. This field is OPTIONAL.
	// An empty string is equal to an unspecified field value.
	FsType string `protobuf:"bytes,1,opt,name=fs_type,json=fsType,proto3" json:"fs_type,omitempty"`
	// The mount options that can be used for the volume. This field is
	// OPTIONAL. `mount_flags` MAY contain sensitive information.
	// Therefore, the CO and the Plugin MUST NOT leak this information
	// to untrusted entities. The total size of this repeated field
	// SHALL NOT exceed 4 KiB.
	MountFlags []string `protobuf:"bytes,2,rep,name=mount_flags,json=mountFlags,proto3" json:"mount_flags,omitempty"`
	// If SP has VOLUME_MOUNT_GROUP node capability and CO provides
	// this field then SP MUST ensure that the volume_mount_group
	// parameter is passed as the group identifier to the underlying
	// operating system mount system call, with the understanding
	// that the set of available mount call parameters and/or
	// mount implementations may vary across operating systems.
	// Additionally, new file and/or directory entries written to
	// the underlying filesystem SHOULD be permission-labeled in such a
	// manner, unless otherwise modified by a workload, that they are
	// both readable and writable by said mount group identifier.
	// This is an OPTIONAL field.
	VolumeMountGroup     string   `protobuf:"bytes,3,opt,name=volume_mount_group,json=volumeMountGroup,proto3" json:"volume_mount_group,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VolumeCapability_MountVolume) Reset()         { *m = VolumeCapability_MountVolume{} }
func (m *VolumeCapability_MountVolume) String() string { return proto.CompactTextString(m) }
func (*VolumeCapability_MountVolume) ProtoMessage()    {}
func (*VolumeCapability_MountVolume) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{10, 1}
}

func (m *VolumeCapability_MountVolume) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeCapability_MountVolume.Unmarshal(m, b)
}
func (m *VolumeCapability_MountVolume) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeCapability_MountVolume.Marshal(b, m, deterministic)
}
func (m *VolumeCapability_MountVolume) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeCapability_MountVolume.Merge(m, src)
}
func (m *VolumeCapability_MountVolume) XXX_Size() int {
	return xxx_messageInfo_VolumeCapability_MountVolume.Size(m)
}
func (m *VolumeCapability_MountVolume) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeCapability_MountVolume.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeCapability_MountVolume proto.InternalMessageInfo

func (m *VolumeCapability_MountVolume) GetFsType() string {
	if m != nil {
		return m.FsType
	}
	return ""
}

func (m *VolumeCapability_MountVolume) GetMountFlags() []string {
	if m != nil {
		return m.MountFlags
	}
	return nil
}

func (m *VolumeCapability_MountVolume) GetVolumeMountGroup() string {
	if m != nil {
		return m.VolumeMountGroup
	}
	return ""
}

// Specify how a volume can be accessed.
type VolumeCapability_AccessMode struct {
	// This field is REQUIRED.
	Mode                 VolumeCapability_AccessMode_Mode `protobuf:"varint,1,opt,name=mode,proto3,enum=csi.v1.VolumeCapability_AccessMode_Mode" json:"mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *VolumeCapability_AccessMode) Reset()         { *m = VolumeCapability_AccessMode{} }
func (m *VolumeCapability_AccessMode) String() string { return proto.CompactTextString(m) }
func (*VolumeCapability_AccessMode) ProtoMessage()    {}
func (*VolumeCapability_AccessMode) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{10, 2}
}

func (m *VolumeCapability_AccessMode) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeCapability_AccessMode.Unmarshal(m, b)
}
func (m *VolumeCapability_AccessMode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeCapability_AccessMode.Marshal(b, m, deterministic)
}
func (m *VolumeCapability_AccessMode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeCapability_AccessMode.Merge(m, src)
}
func (m *VolumeCapability_AccessMode) XXX_Size() int {
	return xxx_messageInfo_VolumeCapability_AccessMode.Size(m)
}
func (m *VolumeCapability_AccessMode) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeCapability_AccessMode.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeCapability_AccessMode proto.InternalMessageInfo

func (m *VolumeCapability_AccessMode) GetMode() VolumeCapability_AccessMode_Mode {
	if m != nil {
		return m.Mode
	}
	return VolumeCapability_AccessMode_UNKNOWN
}

// The capacity of the storage space in bytes. To specify an exact size,
// `required_bytes` and `limit_bytes` SHALL be set to the same value. At
// least one of the these fields MUST be specified.
type CapacityRange struct {
	// Volume MUST be at least this big. This field is OPTIONAL.
	// A value of 0 is equal to an unspecified field value.
	// The value of this field MUST NOT be negative.
	RequiredBytes int64 `protobuf:"varint,1,opt,name=required_bytes,json=requiredBytes,proto3" json:"required_bytes,omitempty"`
	// Volume MUST not be bigger than this. This field is OPTIONAL.
	// A value of 0 is equal to an unspecified field value.
	// The value of this field MUST NOT be negative.
	LimitBytes           int64    `protobuf:"varint,2,opt,name=limit_bytes,json=limitBytes,proto3" json:"limit_bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CapacityRange) Reset()         { *m = CapacityRange{} }
func (m *CapacityRange) String() string { return proto.CompactTextString(m) }
func (*CapacityRange) ProtoMessage()    {}
func (*CapacityRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{11}
}

func (m *CapacityRange) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CapacityRange.Unmarshal(m, b)
}
func (m *CapacityRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CapacityRange.Marshal(b, m, deterministic)
}
func (m *CapacityRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CapacityRange.Merge(m, src)
}
func (m *CapacityRange) XXX_Size() int {
	return xxx_messageInfo_CapacityRange.Size(m)
}
func (m *CapacityRange) XXX_DiscardUnknown() {
	xxx_messageInfo_CapacityRange.DiscardUnknown(m)
}

var xxx_messageInfo_CapacityRange proto.InternalMessageInfo

func (m *CapacityRange) GetRequiredBytes() int64 {
	if m != nil {
		return m.RequiredBytes
	}
	return 0
}

func (m *CapacityRange) GetLimitBytes() int64 {
	if m != nil {
		return m.LimitBytes
	}
	return 0
}

// Information about a specific volume.
type Volume struct {
	// The capacity of the volume in bytes. This field is OPTIONAL. If not
	// set (value of 0), it indicates that the capacity of the volume is
	// unknown (e.g., NFS share).
	// The value of this field MUST NOT be negative.
	CapacityBytes int64 `protobuf:"varint,1,opt,name=capacity_bytes,json=capacityBytes,proto3" json:"capacity_bytes,omitempty"`
	// The identifier for this volume, generated by the plugin.
	// This field is REQUIRED.
	// This field MUST contain enough information to uniquely identify
	// this specific volume vs all other volumes supported by this plugin.
	// This field SHALL be used by the CO in subsequent calls to refer to
	// this volume.
	// The SP is NOT responsible for global uniqueness of volume_id across
	// multiple SPs.
	VolumeId string `protobuf:"bytes,2,opt,name=volume_id,json=volumeId,proto3" json:"volume_id,omitempty"`
	// Opaque static properties of the volume. SP MAY use this field to
	// ensure subsequent volume validation and publishing calls have
	// contextual information.
	// The contents of this field SHALL be opaque to a CO.
	// The contents of this field SHALL NOT be mutable.
	// The contents of this field SHALL be safe for the CO to cache.
	// The contents of this field SHOULD NOT contain sensitive
	// information.
	// The contents of this field SHOULD NOT be used for uniquely
	// identifying a volume. The `volume_id` alone SHOULD be sufficient to
	// identify the volume.
	// A volume uniquely identified by `volume_id` SHALL always report the
	// same volume_context.
	// This field is OPTIONAL and when present MUST be passed to volume
	// validation and publishing calls.
	VolumeContext map[string]string `protobuf:"bytes,3,rep,name=volume_context,json=volumeContext,proto3" json:"volume_context,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// If specified, indicates that the volume is not empty and is
	// pre-populated with data from the specified source.
	// This field is OPTIONAL.
	ContentSource *VolumeContentSource `protobuf:"bytes,4,opt,name=content_source,json=contentSource,proto3" json:"content_source,omitempty"`
	// Specifies where (regions, zones, racks, etc.) the provisioned
	// volume is accessible from.
	// A plugin that returns this field MUST also set the
	// VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
	// An SP MAY specify multiple topologies to indicate the volume is
	// accessible from multiple locations.
	// COs MAY use this information along with the topology information
	// returned by NodeGetInfo to ensure that a given volume is accessible
	// from a given node when scheduling workloads.
	// This field is OPTIONAL. If it is not specified, the CO MAY assume
	// the volume is equally accessible from all nodes in the cluster and
	// MAY schedule workloads referencing the volume on any available
	// node.
	//
	// Example 1:
	//
	//	accessible_topology = {"region": "R1", "zone": "Z2"}
	//
	// Indicates a volume accessible only from the "region" "R1" and the
	// "zone" "Z2".
	//
	// Example 2:
	//
	//	accessible_topology =
	//	  {"region": "R1", "zone": "Z2"},
	//	  {"region": "R1", "zone": "Z3"}
	//
	// Indicates a volume accessible from both "zone" "Z2" and "zone" "Z3"
	// in the "region" "R1".
	AccessibleTopology   []*Topology `protobuf:"bytes,5,rep,name=accessible_topology,json=accessibleTopology,proto3" json:"accessible_topology,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Volume) Reset()         { *m = Volume{} }
func (m *Volume) String() string { return proto.CompactTextString(m) }
func (*Volume) ProtoMessage()    {}
func (*Volume) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{12}
}

func (m *Volume) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Volume.Unmarshal(m, b)
}
func (m *Volume) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Volume.Marshal(b, m, deterministic)
}
func (m *Volume) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Volume.Merge(m, src)
}
func (m *Volume) XXX_Size() int {
	return xxx_messageInfo_Volume.Size(m)
}
func (m *Volume) XXX_DiscardUnknown() {
	xxx_messageInfo_Volume.DiscardUnknown(m)
}

var xxx_messageInfo_Volume proto.InternalMessageInfo

func (m *Volume) GetCapacityBytes() int64 {
	if m != nil {
		return m.CapacityBytes
	}
	return 0
}

func (m *Volume) GetVolumeId() string {
	if m != nil {
		return m.VolumeId
	}
	return ""
}

func (m *Volume) GetVolumeContext() map[string]string {
	if m != nil {
		return m.VolumeContext
	}
	return nil
}

func (m *Volume) GetContentSource() *VolumeContentSource {
	if m != nil {
		return m.ContentSource
	}
	return nil
}

func (m *Volume) GetAccessibleTopology() []*Topology {
	if m != nil {
		return m.AccessibleTopology
	}
	return nil
}

type TopologyRequirement struct {
	// Specifies the list of topologies the provisioned volume MUST be
	// accessible from.
	// This field is OPTIONAL. If TopologyRequirement is specified either
	// requisite or preferred or both MUST be specified.
	//
	// If requisite is specified, the provisioned volume MUST be
	// accessible from at least one of the requisite topologies.
	//
	// Given
	//
	//	x = number of topologies provisioned volume is accessible from
	//	n = number of requisite topologies
	//
	// The CO MUST ensure n >= 1. The SP MUST ensure x >= 1
	// If x==n, then the SP MUST make the provisioned volume available to
	// all topologies from the list of requisite topologies. If it is
	// unable to do so, the SP MUST fail the CreateVolume call.
	// For example, if a volume should be accessible from a single zone,
	// and requisite =
	//
	//	{"region": "R1", "zone": "Z2"}
	//
	// then the provisioned volume MUST be accessible from the "region"
	// "R1" and the "zone" "Z2".
	// Similarly, if a volume should be accessible from two zones, and
	// requisite =
	//
	//	{"region": "R1", "zone": "Z2"},
	//	{"region": "R1", "zone": "Z3"}
	//
	// then the provisioned volume MUST be accessible from the "region"
	// "R1" and both "zone" "Z2" and "zone" "Z3".
	//
	// If x<n, then the SP SHALL choose x unique topologies from the list
	// of requisite topologies. If it is unable to do so, the SP MUST fail
	// the CreateVolume call.
	// For example, if a volume should be accessible from a single zone,
	// and requisite =
	//
	//	{"region": "R1", "zone": "Z2"},
	//	{"region": "R1", "zone": "Z3"}
	//
	// then the SP may choose to make the provisioned volume available in
	// either the "zone" "Z2" or the "zone" "Z3" in the "region" "R1".
	// Similarly, if a volume should be accessible from two zones, and
	// requisite =
	//
	//	{"region": "R1", "zone": "Z2"},
	//	{"region": "R1", "zone": "Z3"},
	//	{"region": "R1", "zone": "Z4"}
	//
	// then the provisioned volume MUST be accessible from any combination
	// of two unique topologies: e.g. "R1/Z2" and "R1/Z3", or "R1/Z2" and
	//
	//	"R1/Z4", or "R1/Z3" and "R1/Z4".
	//
	// If x>n, then the SP MUST make the provisioned volume available from
	// all topologies from the list of requisite topologies and MAY choose
	// the remaining x-n unique topologies from the list of all possible
	// topologies. If it is unable to do so, the SP MUST fail the
	// CreateVolume call.
	// For example, if a volume should be accessible from two zones, and
	// requisite =
	//
	//	{"region": "R1", "zone": "Z2"}
	//
	// then the provisioned volume MUST be accessible from the "region"
	// "R1" and the "zone" "Z2" and the SP may select the second zone
	// independently, e.g. "R1/Z4".
	Requisite []*Topology `protobuf:"bytes,1,rep,name=requisite,proto3" json:"requisite,omitempty"`
	// Specifies the list of topologies the CO would prefer the volume to
	// be provisioned in.
	//
	// This field is OPTIONAL. If TopologyRequirement is specified either
	// requisite or preferred or both MUST be specified.
	//
	// An SP MUST attempt to make the provisioned volume available using
	// the preferred topologies in order from first to last.
	//
	// If requisite is specified, all topologies in preferred list MUST
	// also be present in the list of requisite topologies.
	//
	// If the SP is unable to to make the provisioned volume available
	// from any of the preferred topologies, the SP MAY choose a topology
	// from the list of requisite topologies.
	// If the list of requisite topologies is not specified, then the SP
	// MAY choose from the list of all possible topologies.
	// If the list of requisite topologies is specified and the SP is
	// unable to to make the provisioned volume available from any of the
	// requisite topologies it MUST fail the CreateVolume call.
	//
	// Example 1:
	// Given a volume should be accessible from a single zone, and
	// requisite =
	//
	//	{"region": "R1", "zone": "Z2"},
	//	{"region": "R1", "zone": "Z3"}
	//
	// preferred =
	//
	//	{"region": "R1", "zone": "Z3"}
	//
	// then the SP SHOULD first attempt to make the provisioned volume
	// available from "zone" "Z3" in the "region" "R1" and fall back to
	// "zone" "Z2" in the "region" "R1" if that is not possible.
	//
	// Example 2:
	// Given a volume should be accessible from a single zone, and
	// requisite =
	//
	//	{"region": "R1", "zone": "Z2"},
	//	{"region": "R1", "zone": "Z3"},
	//	{"region": "R1", "zone": "Z4"},
	//	{"region": "R1", "zone": "Z5"}
	//
	// preferred =
	//
	//	{"region": "R1", "zone": "Z4"},
	//	{"region": "R1", "zone": "Z2"}
	//
	// then the SP SHOULD first attempt to make the provisioned volume
	// accessible from "zone" "Z4" in the "region" "R1" and fall back to
	// "zone" "Z2" in the "region" "R1" if that is not possible. If that
	// is not possible, the SP may choose between either the "zone"
	// "Z3" or "Z5" in the "region" "R1".
	//
	// Example 3:
	// Given a volume should be accessible from TWO zones (because an
	// opaque parameter in CreateVolumeRequest, for example, specifies
	// the volume is accessible from two zones, aka synchronously
	// replicated), and
	// requisite =
	//
	//	{"region": "R1", "zone": "Z2"},
	//	{"region": "R1", "zone": "Z3"},
	//	{"region": "R1", "zone": "Z4"},
	//	{"region": "R1", "zone": "Z5"}
	//
	// preferred =
	//
	//	{"region": "R1", "zone": "Z5"},
	//	{"region": "R1", "zone": "Z3"}
	//
	// then the SP SHOULD first attempt to make the provisioned volume
	// accessible from the combination of the two "zones" "Z5" and "Z3" in
	// the "region" "R1". If that's not possible, it should fall back to
	// a combination of "Z5" and other possibilities from the list of
	// requisite. If that's not possible, it should fall back  to a
	// combination of "Z3" and other possibilities from the list of
	// requisite. If that's not possible, it should fall back  to a
	// combination of other possibilities from the list of requisite.
	Preferred            []*Topology `protobuf:"bytes,2,rep,name=preferred,proto3" json:"preferred,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *TopologyRequirement) Reset()         { *m = TopologyRequirement{} }
func (m *TopologyRequirement) String() string { return proto.CompactTextString(m) }
func (*TopologyRequirement) ProtoMessage()    {}
func (*TopologyRequirement) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{13}
}

func (m *TopologyRequirement) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TopologyRequirement.Unmarshal(m, b)
}
func (m *TopologyRequirement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TopologyRequirement.Marshal(b, m, deterministic)
}
func (m *TopologyRequirement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopologyRequirement.Merge(m, src)
}
func (m *TopologyRequirement) XXX_Size() int {
	return xxx_messageInfo_TopologyRequirement.Size(m)
}
func (m *TopologyRequirement) XXX_DiscardUnknown() {
	xxx_messageInfo_TopologyRequirement.DiscardUnknown(m)
}

var xxx_messageInfo_TopologyRequirement proto.InternalMessageInfo

func (m *TopologyRequirement) GetRequisite() []*Topology {
	if m != nil {
		return m.Requisite
	}
	return nil
}

func (m *TopologyRequirement) GetPreferred() []*Topology {
	if m != nil {
		return m.Preferred
	}
	return nil
}

// Topology is a map of topological domains to topological segments.
// A topological domain is a sub-division of a cluster, like "region",
// "zone", "rack", etc.
// A topological segment is a specific instance of a topological domain,
// like "zone3", "rack3", etc.
// For example {"com.company/zone": "Z1", "com.company/rack": "R3"}
// Valid keys have two segments: an OPTIONAL prefix and name, separated
// by a slash (/), for example: "com.company.example/zone".
// The key name segment is REQUIRED. The prefix is OPTIONAL.
// The key name MUST be 63 characters or less, begin and end with an
// alphanumeric character ([a-z0-9A-Z]), and contain only dashes (-),
// underscores (_), dots (.), or alphanumerics in between, for example
// "zone".
// The key prefix MUST be 63 characters or less, begin and end with a
// lower-case alphanumeric character ([a-z0-9]), contain only
// dashes (-), dots (.), or lower-case alphanumerics in between, and
// follow domain name notation format
// (https://tools.ietf.org/html/rfc1035#section-2.3.1).
// The key prefix SHOULD include the plugin's host company name and/or
// the plugin name, to minimize the possibility of collisions with keys
// from other plugins.
// If a key prefix is specified, it MUST be identical across all
// topology keys returned by the SP (across all RPCs).
// Keys MUST be case-insensitive. Meaning the keys "Zone" and "zone"
// MUST not both exist.
// Each value (topological segment) MUST contain 1 or more strings.
// Each string MUST be 63 characters or less and begin and end with an
// alphanumeric character with '-', '_', '.', or alphanumerics in
// between.
type Topology struct {
	Segments             map[string]string `protobuf:"bytes,1,rep,name=segments,proto3" json:"segments,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Topology) Reset()         { *m = Topology{} }
func (m *Topology) String() string { return proto.CompactTextString(m) }
func (*Topology) ProtoMessage()    {}
func (*Topology) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{14}
}

func (m *Topology) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Topology.Unmarshal(m, b)
}
func (m *Topology) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Topology.Marshal(b, m, deterministic)
}
func (m *Topology) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Topology.Merge(m, src)
}
func (m *Topology) XXX_Size() int {
	return xxx_messageInfo_Topology.Size(m)
}
func (m *Topology) XXX_DiscardUnknown() {
	xxx_messageInfo_Topology.DiscardUnknown(m)
}

var xxx_messageInfo_Topology proto.InternalMessageInfo

func (m *Topology) GetSegments() map[string]string {
	if m != nil {
		return m.Segments
	}
	return nil
}

type DeleteVolumeRequest struct {
	// The ID of the volume to be deprovisioned.
	// This field is REQUIRED.
	VolumeId string `protobuf:"bytes,1,opt,name=volume_id,json=volumeId,proto3" json:"volume_id,omitempty"`
	// Secrets required by plugin to complete volume deletion request.
	// This field is OPTIONAL. Refer to the `Secrets Requirements`
	// section on how to use this field.
	Secrets              map[string]string `protobuf:"bytes,2,rep,name=secrets,proto3" json:"secrets,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *DeleteVolumeRequest) Reset()         { *m = DeleteVolumeRequest{} }
func (m *DeleteVolumeRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteVolumeRequest) ProtoMessage()    {}
func (*DeleteVolumeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{15}
}

func (m *DeleteVolumeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DeleteVolumeRequest.Unmarshal(m, b)
}
func (m *DeleteVolumeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DeleteVolumeRequest.Marshal(b, m, deterministic)
}
func (m *DeleteVolumeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteVolumeRequest.Merge(m, src)
}
func (m *DeleteVolumeRequest) XXX_Size() int {
	return xxx_messageInfo_DeleteVolumeRequest.Size(m)
}
func (m *DeleteVolumeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteVolumeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteVolumeRequest proto.InternalMessageInfo

func (m *DeleteVolumeRequest) GetVolumeId() string {
	if m != nil {
		return m.VolumeId
	}
	return ""
}

func (m *DeleteVolumeRequest) GetSecrets() map[string]string {
	if m != nil {
		return m.Secrets
	}
	return nil
}

type DeleteVolumeResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteVolumeResponse) Reset()         { *m = DeleteVolumeResponse{} }
func (m *DeleteVolumeResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteVolumeResponse) ProtoMessage()    {}
func (*DeleteVolumeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{16}
}

func (m *DeleteVolumeResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DeleteVolumeResponse.Unmarshal(m, b)
}
func (m *DeleteVolumeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DeleteVolumeResponse.Marshal(b, m, deterministic)
}
func (m *DeleteVolumeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteVolumeResponse.Merge(m, src)
}
func (m *DeleteVolumeResponse) XXX_Size() int {
	return xxx_messageInfo_DeleteVolumeResponse.Size(m)
}
func (m *DeleteVolumeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteVolumeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteVolumeResponse proto.InternalMessageInfo

type ControllerPublishVolumeRequest struct {
	// The ID of the volume to be used on a node.
	// This field is REQUIRED.
	VolumeId string `protobuf:"bytes,1,opt,name=volume_id,json=volumeId,proto3" json:"volume_id,omitempty"`
	// The ID of the node. This field is REQUIRED. The CO SHALL set this
	// field to match the node ID returned by `NodeGetInfo`.
	NodeId string `protobuf:"bytes,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// Volume capability describing how the CO intends to use this volume.
	// SP MUST ensure the CO can use the published volume as described.
	// Otherwise SP MUST return the appropriate gRPC error code.
	// This is a REQUIRED field.
	VolumeCapability *VolumeCapability `protobuf:"bytes,3,opt,name=volume_capability,json=volumeCapability,proto3" json:"volume_capability,omitempty"`
	// Indicates SP MUST publish the volume in readonly mode.
	// CO MUST set this field to false if SP does not have the
	// PUBLISH_READONLY controller capability.
	// This is a REQUIRED field.
	Readonly bool `protobuf:"varint,4,opt,name=readonly,proto3" json:"readonly,omitempty"`
	// Secrets required by plugin to complete controller publish volume
	// request. This field is OPTIONAL. Refer to the
	// `Secrets Requirements` section on how to use this field.
	Secrets map[string]string `protobuf:"bytes,5,rep,name=secrets,proto3" json:"secrets,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Volume context as returned by SP in
	// CreateVolumeResponse.Volume.volume_context.
	// This field is OPTIONAL and MUST match the volume_context of the
	// volume identified by `volume_id`.
	VolumeContext        map[string]string `protobuf:"bytes,6,rep,name=volume_context,json=volumeContext,proto3" json:"volume_context,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ControllerPublishVolumeRequest) Reset()         { *m = ControllerPublishVolumeRequest{} }
func (m *ControllerPublishVolumeRequest) String() string { return proto.CompactTextString(m) }
func (*ControllerPublishVolumeRequest) ProtoMessage()    {}
func (*ControllerPublishVolumeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{17}
}

func (m *ControllerPublishVolumeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ControllerPublishVolumeRequest.Unmarshal(m, b)
}
func (m *ControllerPublishVolumeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ControllerPublishVolumeRequest.Marshal(b, m, deterministic)
}
func (m *ControllerPublishVolumeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControllerPublishVolumeRequest.Merge(m, src)
}
func (m *ControllerPublishVolumeRequest) XXX_Size() int {
	return xxx_messageInfo_ControllerPublishVolumeRequest.Size(m)
}
func (m *ControllerPublishVolumeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ControllerPublishVolumeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ControllerPublishVolumeRequest proto.InternalMessageInfo

func (m *ControllerPublishVolumeRequest) GetVolumeId() string {
	if m != nil {
		return m.VolumeId
	}
	return ""
}

func (m *ControllerPublishVolumeRequest) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

func (m *ControllerPublishVolumeRequest) GetVolumeCapability() *VolumeCapability {
	if m != nil {
		return m.VolumeCapability
	}
	return nil
}

func (m *ControllerPublishVolumeRequest) GetReadonly() bool {
	if m != nil {
		return m.Readonly
	}
	return false
}

func (m *ControllerPublishVolumeRequest) GetSecrets() map[string]string {
	if m != nil {
		return m.Secrets
	}
	return nil
}

func (m *ControllerPublishVolumeRequest) GetVolumeContext() map[string]string {
	if m != nil {
		return m.VolumeContext
	}
	return nil
}

type ControllerPublishVolumeResponse struct {
	// Opaque static publish properties of the volume. SP MAY use this
	// field to ensure subsequent `NodeStageVolume` or `NodePublishVolume`
	// calls calls have contextual information.
	// The contents of this field SHALL be opaque to a CO.
	// The contents of this field SHALL NOT be mutable.
	// The contents of this field SHALL be safe for the CO to cache.
	// The contents of this field SHOULD NOT contain sensitive
	// information.
	// The contents of this field SHOULD NOT be used for uniquely
	// identifying a volume. The `volume_id` alone SHOULD be sufficient to
	// identify the volume.
	// This field is OPTIONAL and when present MUST be passed to
	// subsequent `NodeStageVolume` or `NodePublishVolume` calls
	PublishContext       map[string]string `protobuf:"bytes,1,rep,name=publish_context,json=publishContext,proto3" json:"publish_context,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ControllerPublishVolumeResponse) Reset()         { *m = ControllerPublishVolumeResponse{} }
func (m *ControllerPublishVolumeResponse) String() string { return proto.CompactTextString(m) }
func (*ControllerPublishVolumeResponse) ProtoMessage()    {}
func (*ControllerPublishVolumeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{18}
}

func (m *ControllerPublishVolumeResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ControllerPublishVolumeResponse.Unmarshal(m, b)
}
func (m *ControllerPublishVolumeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ControllerPublishVolumeResponse.Marshal(b, m, deterministic)
}
func (m *ControllerPublishVolumeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControllerPublishVolumeResponse.Merge(m, src)
}
func (m *ControllerPublishVolumeResponse) XXX_Size() int {
	return xxx_messageInfo_ControllerPublishVolumeResponse.Size(m)
}
func (m *ControllerPublishVolumeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ControllerPublishVolumeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ControllerPublishVolumeResponse proto.InternalMessageInfo

func (m *ControllerPublishVolumeResponse) GetPublishContext() map[string]string {
	if m != nil {
		return m.PublishContext
	}
	return nil
}

type ControllerUnpublishVolumeRequest struct {
	// The ID of the volume. This field is REQUIRED.
	VolumeId string `protobuf:"bytes,1,opt,name=volume_id,json=volumeId,proto3" json:"volume_id,omitempty"`
	// The ID of the node. This field is OPTIONAL. The CO SHOULD set this
	// field to match the node ID returned by `NodeGetInfo` or leave it
	// unset. If the value is set, the SP MUST unpublish the volume from
	// the specified node. If the value is unset, the SP MUST unpublish
	// the volume from all nodes it is published to.
	NodeId string `protobuf:"bytes,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// Secrets required by plugin to complete controller unpublish volume
	// request. This SHOULD be the same secrets passed to the
	// ControllerPublishVolume call for the specified volume.
	// This field is OPTIONAL. Refer to the `Secrets Requirements`
	// section on how to use this field.
	Secrets              map[string]string `protobuf:"bytes,3,rep,name=secrets,proto3" json:"secrets,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ControllerUnpublishVolumeRequest) Reset()         { *m = ControllerUnpublishVolumeRequest{} }
func (m *ControllerUnpublishVolumeRequest) String() string { return proto.CompactTextString(m) }
func (*ControllerUnpublishVolumeRequest) ProtoMessage()    {}
func (*ControllerUnpublishVolumeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{19}
}

func (m *ControllerUnpublishVolumeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ControllerUnpublishVolumeRequest.Unmarshal(m, b)
}
func (m *ControllerUnpublishVolumeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ControllerUnpublishVolumeRequest.Marshal(b, m, deterministic)
}
func (m *ControllerUnpublishVolumeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControllerUnpublishVolumeRequest.Merge(m, src)
}
func (m *ControllerUnpublishVolumeRequest) XXX_Size() int {
	return xxx_messageInfo_ControllerUnpublishVolumeRequest.Size(m)
}
func (m *ControllerUnpublishVolumeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ControllerUnpublishVolumeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ControllerUnpublishVolumeRequest proto.InternalMessageInfo

func (m *ControllerUnpublishVolumeRequest) GetVolumeId() string {
	if m != nil {
		return m.VolumeId
	}
	return ""
}

func (m *ControllerUnpublishVolumeRequest) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

func (m *ControllerUnpublishVolumeRequest) GetSecrets() map[string]string {
	if m != nil {
		return m.Secrets
	}
	return nil
}

type ControllerUnpublishVolumeResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ControllerUnpublishVolumeResponse) Reset()         { *m = ControllerUnpublishVolumeResponse{} }
func (m *ControllerUnpublishVolumeResponse) String() string { return proto.CompactTextString(m) }
func (*ControllerUnpublishVolumeResponse) ProtoMessage()    {}
func (*ControllerUnpublishVolumeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{20}
}

func (m *ControllerUnpublishVolumeResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ControllerUnpublishVolumeResponse.Unmarshal(m, b)
}
func (m *ControllerUnpublishVolumeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ControllerUnpublishVolumeResponse.Marshal(b, m, deterministic)
}
func (m *ControllerUnpublishVolumeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControllerUnpublishVolumeResponse.Merge(m, src)
}
func (m *ControllerUnpublishVolumeResponse) XXX_Size() int {
	return xxx_messageInfo_ControllerUnpublishVolumeResponse.Size(m)
}
func (m *ControllerUnpublishVolumeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ControllerUnpublishVolumeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ControllerUnpublishVolumeResponse proto.InternalMessageInfo

type ValidateVolumeCapabilitiesRequest struct {
	// The ID of the volume to check. This field is REQUIRED.
	VolumeId string `protobuf:"bytes,1,opt,name=volume_id,json=volumeId,proto3" json:"volume_id,omitempty"`
	// Volume context as returned by SP in
	// CreateVolumeResponse.Volume.volume_context.
	// This field is OPTIONAL and MUST match the volume_context of the
	// volume identified by `volume_id`.
	VolumeContext map[string]string `protobuf:"bytes,2,rep,name=volume_context,json=volumeContext,proto3" json:"volume_context,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// The capabilities that the CO wants to check for the volume. This
	// call SHALL return "confirmed" only if all the volume capabilities
	// specified below are supported. This field is REQUIRED.
	VolumeCapabilities []*VolumeCapability `protobuf:"bytes,3,rep,name=volume_capabilities,json=volumeCapabilities,proto3" json:"volume_capabilities,omitempty"`
	// See CreateVolumeRequest.parameters.
	// This field is OPTIONAL.
	Parameters map[string]string `protobuf:"bytes,4,rep,name=parameters,proto3" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Secrets required by plugin to complete volume validation request.
	// This field is OPTIONAL. Refer to the `Secrets Requirements`
	// section on how to use this field.
	Secrets              map[string]string `protobuf:"bytes,5,rep,name=secrets,proto3" json:"secrets,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ValidateVolumeCapabilitiesRequest) Reset()         { *m = ValidateVolumeCapabilitiesRequest{} }
func (m *ValidateVolumeCapabilitiesRequest) String() string { return proto.CompactTextString(m) }
func (*ValidateVolumeCapabilitiesRequest) ProtoMessage()    {}
func (*ValidateVolumeCapabilitiesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{21}
}

func (m *ValidateVolumeCapabilitiesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ValidateVolumeCapabilitiesRequest.Unmarshal(m, b)
}
func (m *ValidateVolumeCapabilitiesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ValidateVolumeCapabilitiesRequest.Marshal(b, m, deterministic)
}
func (m *ValidateVolumeCapabilitiesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateVolumeCapabilitiesRequest.Merge(m, src)
}
func (m *ValidateVolumeCapabilitiesRequest) XXX_Size() int {
	return xxx_messageInfo_ValidateVolumeCapabilitiesRequest.Size(m)
}
func (m *ValidateVolumeCapabilitiesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateVolumeCapabilitiesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateVolumeCapabilitiesRequest proto.InternalMessageInfo

func (m *ValidateVolumeCapabilitiesRequest) GetVolumeId() string {
	if m != nil {
		return m.VolumeId
	}
	return ""
}

func (m *ValidateVolumeCapabilitiesRequest) GetVolumeContext() map[string]string {
	if m != nil {
		return m.VolumeContext
	}
	return nil
}

func (m *ValidateVolumeCapabilitiesRequest) GetVolumeCapabilities() []*VolumeCapability {
	if m != nil {
		return m.VolumeCapabilities
	}
	return nil
}

func (m *ValidateVolumeCapabilitiesRequest) GetParameters() map[string]string {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *ValidateVolumeCapabilitiesRequest) GetSecrets() map[string]string {
	if m != nil {
		return m.Secrets
	}
	return nil
}

type ValidateVolumeCapabilitiesResponse struct {
	// Confirmed indicates to the CO the set of capabilities that the
	// plugin has validated. This field SHALL only be set to a non-empty
	// value for successful validation responses.
	// For successful validation responses, the CO SHALL compare the
	// fields of this message to the originally requested capabilities in
	// order to guard against an older plugin reporting "valid" for newer
	// capability fields that it does not yet understand.
	// This field is OPTIONAL.
	Confirmed *ValidateVolumeCapabilitiesResponse_Confirmed `protobuf:"bytes,1,opt,name=confirmed,proto3" json:"confirmed,omitempty"`
	// Message to the CO if `confirmed` above is empty. This field is
	// OPTIONAL.
	// An empty string is equal to an unspecified field value.
	Message              string   `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ValidateVolumeCapabilitiesResponse) Reset()         { *m = ValidateVolumeCapabilitiesResponse{} }
func (m *ValidateVolumeCapabilitiesResponse) String() string { return proto.CompactTextString(m) }
func (*ValidateVolumeCapabilitiesResponse) ProtoMessage()    {}
func (*ValidateVolumeCapabilitiesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{22}
}

func (m *ValidateVolumeCapabilitiesResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ValidateVolumeCapabilitiesResponse.Unmarshal(m, b)
}
func (m *ValidateVolumeCapabilitiesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ValidateVolumeCapabilitiesResponse.Marshal(b, m, deterministic)
}
func (m *ValidateVolumeCapabilitiesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateVolumeCapabilitiesResponse.Merge(m, src)
}
func (m *ValidateVolumeCapabilitiesResponse) XXX_Size() int {
	return xxx_messageInfo_ValidateVolumeCapabilitiesResponse.Size(m)
}
func (m *ValidateVolumeCapabilitiesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateVolumeCapabilitiesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateVolumeCapabilitiesResponse proto.InternalMessageInfo

func (m *ValidateVolumeCapabilitiesResponse) GetConfirmed() *ValidateVolumeCapabilitiesResponse_Confirmed {
	if m != nil {
		return m.Confirmed
	}
	return nil
}

func (m *ValidateVolumeCapabilitiesResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type ValidateVolumeCapabilitiesResponse_Confirmed struct {
	// Volume context validated by the plugin.
	// This field is OPTIONAL.
	VolumeContext map[string]string `protobuf:"bytes,1,rep,name=volume_context,json=volumeContext,proto3" json:"volume_context,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Volume capabilities supported by the plugin.
	// This field is REQUIRED.
	VolumeCapabilities []*VolumeCapability `protobuf:"bytes,2,rep,name=volume_capabilities,json=volumeCapabilities,proto3" json:"volume_capabilities,omitempty"`
	// The volume creation parameters validated by the plugin.
	// This field is OPTIONAL.
	Parameters           map[string]string `protobuf:"bytes,3,rep,name=parameters,proto3" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ValidateVolumeCapabilitiesResponse_Confirmed) Reset() {
	*m = ValidateVolumeCapabilitiesResponse_Confirmed{}
}
func (m *ValidateVolumeCapabilitiesResponse_Confirmed) String() string {
	return proto.CompactTextString(m)
}
func (*ValidateVolumeCapabilitiesResponse_Confirmed) ProtoMessage() {}
func (*ValidateVolumeCapabilitiesResponse_Confirmed) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{22, 0}
}

func (m *ValidateVolumeCapabilitiesResponse_Confirmed) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ValidateVolumeCapabilitiesResponse_Confirmed.Unmarshal(m, b)
}
func (m *ValidateVolumeCapabilitiesResponse_Confirmed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ValidateVolumeCapabilitiesResponse_Confirmed.Marshal(b, m, deterministic)
}
func (m *ValidateVolumeCapabilitiesResponse_Confirmed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateVolumeCapabilitiesResponse_Confirmed.Merge(m, src)
}
func (m *ValidateVolumeCapabilitiesResponse_Confirmed) XXX_Size() int {
	return xxx_messageInfo_ValidateVolumeCapabilitiesResponse_Confirmed.Size(m)
}
func (m *ValidateVolumeCapabilitiesResponse_Confirmed) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateVolumeCapabilitiesResponse_Confirmed.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateVolumeCapabilitiesResponse_Confirmed proto.InternalMessageInfo

func (m *ValidateVolumeCapabilitiesResponse_Confirmed) GetVolumeContext() map[string]string {
	if m != nil {
		return m.VolumeContext
	}
	return nil
}

func (m *ValidateVolumeCapabilitiesResponse_Confirmed) GetVolumeCapabilities() []*VolumeCapability {
	if m != nil {
		return m.VolumeCapabilities
	}
	return nil
}

func (m *ValidateVolumeCapabilitiesResponse_Confirmed) GetParameters() map[string]string {
	if m != nil {
		return m.Parameters
	}
	return nil
}

type ListVolumesRequest struct {
	// If specified (non-zero value), the Plugin MUST NOT return more
	// entries than this number in the response. If the actual number of
	// entries is more than this number, the Plugin MUST set `next_token`
	// in the response which can be used to get the next page of entries
	// in the subsequent `ListVolumes` call. This field is OPTIONAL. If
	// not specified (zero value), it means there is no restriction on the
	// number of entries that can be returned.
	// The value of this field MUST NOT be negative.
	MaxEntries int32 `protobuf:"varint,1,opt,name=max_entries,json=maxEntries,proto3" json:"max_entries,omitempty"`
	// A token to specify where to start paginating. Set this field to
	// `next_token` returned by a previous `ListVolumes` call to get the
	// next page of entries. This field is OPTIONAL.
	// An empty string is equal to an unspecified field value.
	StartingToken        string   `protobuf:"bytes,2,opt,name=starting_token,json=startingToken,proto3" json:"starting_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListVolumesRequest) Reset()         { *m = ListVolumesRequest{} }
func (m *ListVolumesRequest) String() string { return proto.CompactTextString(m) }
func (*ListVolumesRequest) ProtoMessage()    {}
func (*ListVolumesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{23}
}

func (m *ListVolumesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListVolumesRequest.Unmarshal(m, b)
}
func (m *ListVolumesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListVolumesRequest.Marshal(b, m, deterministic)
}
func (m *ListVolumesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListVolumesRequest.Merge(m, src)
}
func (m *ListVolumesRequest) XXX_Size() int {
	return xxx_messageInfo_ListVolumesRequest.Size(m)
}
func (m *ListVolumesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListVolumesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListVolumesRequest proto.InternalMessageInfo

func (m *ListVolumesRequest) GetMaxEntries() int32 {
	if m != nil {
		return m.MaxEntries
	}
	return 0
}

func (m *ListVolumesRequest) GetStartingToken() string {
	if m != nil {
		return m.StartingToken
	}
	return ""
}

type ListVolumesResponse struct {
	Entries []*ListVolumesResponse_Entry `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty"`
	// This token allows you to get the next page of entries for
	// `ListVolumes` request. If the number of entries is larger than
	// `max_entries`, use the `next_token` as a value for the
	// `starting_token` field in the next `ListVolumes` request. This
	// field is OPTIONAL.
	// An empty string is equal to an unspecified field value.
	NextToken            string   `protobuf:"bytes,2,opt,name=next_token,json=nextToken,proto3" json:"next_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListVolumesResponse) Reset()         { *m = ListVolumesResponse{} }
func (m *ListVolumesResponse) String() string { return proto.CompactTextString(m) }
func (*ListVolumesResponse) ProtoMessage()    {}
func (*ListVolumesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{24}
}

func (m *ListVolumesResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListVolumesResponse.Unmarshal(m, b)
}
func (m *ListVolumesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListVolumesResponse.Marshal(b, m, deterministic)
}
func (m *ListVolumesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListVolumesResponse.Merge(m, src)
}
func (m *ListVolumesResponse) XXX_Size() int {
	return xxx_messageInfo_ListVolumesResponse.Size(m)
}
func (m *ListVolumesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListVolumesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListVolumesResponse proto.InternalMessageInfo

func (m *ListVolumesResponse) GetEntries() []*ListVolumesResponse_Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

func (m *ListVolumesResponse) GetNextToken() string {
	if m != nil {
		return m.NextToken
	}
	return ""
}

type ListVolumesResponse_VolumeStatus struct {
	// A list of all `node_id` of nodes that the volume in this entry
	// is controller published on.
	// This field is OPTIONAL. If it is not specified and the SP has
	// the LIST_VOLUMES_PUBLISHED_NODES controller capability, the CO
	// MAY assume the volume is not controller published to any nodes.
	// If the field is not specified and the SP does not have the
	// LIST_VOLUMES_PUBLISHED_NODES controller capability, the CO MUST
	// not interpret this field.
	// published_node_ids MAY include nodes not published to or
	// reported by the SP. The CO MUST be resilient to that.
	PublishedNodeIds []string `protobuf:"bytes,1,rep,name=published_node_ids,json=publishedNodeIds,proto3" json:"published_node_ids,omitempty"`
	// Information about the current condition of the volume.
	// This field is OPTIONAL.
	// This field MUST be specified if the
	// VOLUME_CONDITION controller capability is supported.
	VolumeCondition      *VolumeCondition `protobuf:"bytes,2,opt,name=volume_condition,json=volumeCondition,proto3" json:"volume_condition,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ListVolumesResponse_VolumeStatus) Reset()         { *m = ListVolumesResponse_VolumeStatus{} }
func (m *ListVolumesResponse_VolumeStatus) String() string { return proto.CompactTextString(m) }
func (*ListVolumesResponse_VolumeStatus) ProtoMessage()    {}
func (*ListVolumesResponse_VolumeStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{24, 0}
}

func (m *ListVolumesResponse_VolumeStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListVolumesResponse_VolumeStatus.Unmarshal(m, b)
}
func (m *ListVolumesResponse_VolumeStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListVolumesResponse_VolumeStatus.Marshal(b, m, deterministic)
}
func (m *ListVolumesResponse_VolumeStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListVolumesResponse_VolumeStatus.Merge(m, src)
}
func (m *ListVolumesResponse_VolumeStatus) XXX_Size() int {
	return xxx_messageInfo_ListVolumesResponse_VolumeStatus.Size(m)
}
func (m *ListVolumesResponse_VolumeStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ListVolumesResponse_VolumeStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ListVolumesResponse_VolumeStatus proto.InternalMessageInfo

func (m *ListVolumesResponse_VolumeStatus) GetPublishedNodeIds() []string {
	if m != nil {
		return m.PublishedNodeIds
	}
	return nil
}

func (m *ListVolumesResponse_VolumeStatus) GetVolumeCondition() *VolumeCondition {
	if m != nil {
		return m.VolumeCondition
	}
	return nil
}

type ListVolumesResponse_Entry struct {
	// This field is REQUIRED
	Volume *Volume `protobuf:"bytes,1,opt,name=volume,proto3" json:"volume,omitempty"`
	// This field is OPTIONAL. This field MUST be specified if the
	// LIST_VOLUMES_PUBLISHED_NODES controller capability is
	// supported.
	Status               *ListVolumesResponse_VolumeStatus `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-"`
	XXX_unrecognized     []byte                            `json:"-"`
	XXX_sizecache        int32                             `json:"-"`
}

func (m *ListVolumesResponse_Entry) Reset()         { *m = ListVolumesResponse_Entry{} }
func (m *ListVolumesResponse_Entry) String() string { return proto.CompactTextString(m) }
func (*ListVolumesResponse_Entry) ProtoMessage()    {}
func (*ListVolumesResponse_Entry) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{24, 1}
}

func (m *ListVolumesResponse_Entry) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListVolumesResponse_Entry.Unmarshal(m, b)
}
func (m *ListVolumesResponse_Entry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListVolumesResponse_Entry.Marshal(b, m, deterministic)
}
func (m *ListVolumesResponse_Entry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListVolumesResponse_Entry.Merge(m, src)
}
func (m *ListVolumesResponse_Entry) XXX_Size() int {
	return xxx_messageInfo_ListVolumesResponse_Entry.Size(m)
}
func (m *ListVolumesResponse_Entry) XXX_DiscardUnknown() {
	xxx_messageInfo_ListVolumesResponse_Entry.DiscardUnknown(m)
}

var xxx_messageInfo_ListVolumesResponse_Entry proto.InternalMessageInfo

func (m *ListVolumesResponse_Entry) GetVolume() *Volume {
	if m != nil {
		return m.Volume
	}
	return nil
}

func (m *ListVolumesResponse_Entry) GetStatus() *ListVolumesResponse_VolumeStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type ControllerGetVolumeRequest struct {
	// The ID of the volume to fetch current volume information for.
	// This field is REQUIRED.
	VolumeId             string   `protobuf:"bytes,1,opt,name=volume_id,json=volumeId,proto3" json:"volume_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ControllerGetVolumeRequest) Reset()         { *m = ControllerGetVolumeRequest{} }
func (m *ControllerGetVolumeRequest) String() string { return proto.CompactTextString(m) }
func (*ControllerGetVolumeRequest) ProtoMessage()    {}
func (*ControllerGetVolumeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{25}
}

func (m *ControllerGetVolumeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ControllerGetVolumeRequest.Unmarshal(m, b)
}
func (m *ControllerGetVolumeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ControllerGetVolumeRequest.Marshal(b, m, deterministic)
}
func (m *ControllerGetVolumeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControllerGetVolumeRequest.Merge(m, src)
}
func (m *ControllerGetVolumeRequest) XXX_Size() int {
	return xxx_messageInfo_ControllerGetVolumeRequest.Size(m)
}
func (m *ControllerGetVolumeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ControllerGetVolumeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ControllerGetVolumeRequest proto.InternalMessageInfo

func (m *ControllerGetVolumeRequest) GetVolumeId() string {
	if m != nil {
		return m.VolumeId
	}
	return ""
}

type ControllerGetVolumeResponse struct {
	// This field is REQUIRED
	Volume *Volume `protobuf:"bytes,1,opt,name=volume,proto3" json:"volume,omitempty"`
	// This field is REQUIRED.
	Status               *ControllerGetVolumeResponse_VolumeStatus `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                  `json:"-"`
	XXX_unrecognized     []byte                                    `json:"-"`
	XXX_sizecache        int32                                     `json:"-"`
}

func (m *ControllerGetVolumeResponse) Reset()         { *m = ControllerGetVolumeResponse{} }
func (m *ControllerGetVolumeResponse) String() string { return proto.CompactTextString(m) }
func (*ControllerGetVolumeResponse) ProtoMessage()    {}
func (*ControllerGetVolumeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{26}
}

func (m *ControllerGetVolumeResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ControllerGetVolumeResponse.Unmarshal(m, b)
}
func (m *ControllerGetVolumeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ControllerGetVolumeResponse.Marshal(b, m, deterministic)
}
func (m *ControllerGetVolumeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControllerGetVolumeResponse.Merge(m, src)
}
func (m *ControllerGetVolumeResponse) XXX_Size() int {
	return xxx_messageInfo_ControllerGetVolumeResponse.Size(m)
}
func (m *ControllerGetVolumeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ControllerGetVolumeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ControllerGetVolumeResponse proto.InternalMessageInfo

func (m *ControllerGetVolumeResponse) GetVolume() *Volume {
	if m != nil {
		return m.Volume
	}
	return nil
}

func (m *ControllerGetVolumeResponse) GetStatus() *ControllerGetVolumeResponse_VolumeStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type ControllerGetVolumeResponse_VolumeStatus struct {
	// A list of all the `node_id` of nodes that this volume is
	// controller published on.
	// This field is OPTIONAL.
	// This field MUST be specified if the LIST_VOLUMES_PUBLISHED_NODES
	// controller capability is supported.
	// published_node_ids MAY include nodes not published to or
	// reported by the SP. The CO MUST be resilient to that.
	PublishedNodeIds []string `protobuf:"bytes,1,rep,name=published_node_ids,json=publishedNodeIds,proto3" json:"published_node_ids,omitempty"`
	// Information about the current condition of the volume.
	// This field is OPTIONAL.
	// This field MUST be specified if the
	// VOLUME_CONDITION controller capability is supported.
	VolumeCondition      *VolumeCondition `protobuf:"bytes,2,opt,name=volume_condition,json=volumeCondition,proto3" json:"volume_condition,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ControllerGetVolumeResponse_VolumeStatus) Reset() {
	*m = ControllerGetVolumeResponse_VolumeStatus{}
}
func (m *ControllerGetVolumeResponse_VolumeStatus) String() string { return proto.CompactTextString(m) }
func (*ControllerGetVolumeResponse_VolumeStatus) ProtoMessage()    {}
func (*ControllerGetVolumeResponse_VolumeStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{26, 0}
}

func (m *ControllerGetVolumeResponse_VolumeStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ControllerGetVolumeResponse_VolumeStatus.Unmarshal(m, b)
}
func (m *ControllerGetVolumeResponse_VolumeStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ControllerGetVolumeResponse_VolumeStatus.Marshal(b, m, deterministic)
}
func (m *ControllerGetVolumeResponse_VolumeStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControllerGetVolumeResponse_VolumeStatus.Merge(m, src)
}
func (m *ControllerGetVolumeResponse_VolumeStatus) XXX_Size() int {
	return xxx_messageInfo_ControllerGetVolumeResponse_VolumeStatus.Size(m)
}
func (m *ControllerGetVolumeResponse_VolumeStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ControllerGetVolumeResponse_VolumeStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ControllerGetVolumeResponse_VolumeStatus proto.InternalMessageInfo

func (m *ControllerGetVolumeResponse_VolumeStatus) GetPublishedNodeIds() []string {
	if m != nil {
		return m.PublishedNodeIds
	}
	return nil
}

func (m *ControllerGetVolumeResponse_VolumeStatus) GetVolumeCondition() *VolumeCondition {
	if m != nil {
		return m.VolumeCondition
	}
	return nil
}

type GetCapacityRequest struct {
	// If specified, the Plugin SHALL report the capacity of the storage
	// that can be used to provision volumes that satisfy ALL of the
	// specified `volume_capabilities`. These are the same
	// `volume_capabilities` the CO will use in `CreateVolumeRequest`.
	// This field is OPTIONAL.
	VolumeCapabilities []*VolumeCapability `protobuf:"bytes,1,rep,name=volume_capabilities,json=volumeCapabilities,proto3" json:"volume_capabilities,omitempty"`
	// If specified, the Plugin SHALL report the capacity of the storage
	// that can be used to provision volumes with the given Plugin
	// specific `parameters`. These are the same `parameters` the CO will
	// use in `CreateVolumeRequest`. This field is OPTIONAL.
	Parameters map[string]string `protobuf:"bytes,2,rep,name=parameters,proto3" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// If specified, the Plugin SHALL report the capacity of the storage
	// that can be used to provision volumes that in the specified
	// `accessible_topology`. This is the same as the
	// `accessible_topology` the CO returns in a `CreateVolumeResponse`.
	// This field is OPTIONAL. This field SHALL NOT be set unless the
	// plugin advertises the VOLUME_ACCESSIBILITY_CONSTRAINTS capability.
	AccessibleTopology   *Topology `protobuf:"bytes,3,opt,name=accessible_topology,json=accessibleTopology,proto3" json:"accessible_topology,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *GetCapacityRequest) Reset()         { *m = GetCapacityRequest{} }
func (m *GetCapacityRequest) String() string { return proto.CompactTextString(m) }
func (*GetCapacityRequest) ProtoMessage()    {}
func (*GetCapacityRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{27}
}

func (m *GetCapacityRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetCapacityRequest.Unmarshal(m, b)
}
func (m *GetCapacityRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetCapacityRequest.Marshal(b, m, deterministic)
}
func (m *GetCapacityRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCapacityRequest.Merge(m, src)
}
func (m *GetCapacityRequest) XXX_Size() int {
	return xxx_messageInfo_GetCapacityRequest.Size(m)
}
func (m *GetCapacityRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCapacityRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetCapacityRequest proto.InternalMessageInfo

func (m *GetCapacityRequest) GetVolumeCapabilities() []*VolumeCapability {
	if m != nil {
		return m.VolumeCapabilities
	}
	return nil
}

func (m *GetCapacityRequest) GetParameters() map[string]string {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *GetCapacityRequest) GetAccessibleTopology() *Topology {
	if m != nil {
		return m.AccessibleTopology
	}
	return nil
}

type GetCapacityResponse struct {
	// The available capacity, in bytes, of the storage that can be used
	// to provision volumes. If `volume_capabilities` or `parameters` is
	// specified in the request, the Plugin SHALL take those into
	// consideration when calculating the available capacity of the
	// storage. This field is REQUIRED.
	// The value of this field MUST NOT be negative.
	AvailableCapacity int64 `protobuf:"varint,1,opt,name=available_capacity,json=availableCapacity,proto3" json:"available_capacity,omitempty"`
	// The largest size that may be used in a
	// CreateVolumeRequest.capacity_range.required_bytes field
	// to create a volume with the same parameters as those in
	// GetCapacityRequest.
	//
	// If `volume_capabilities` or `parameters` is
	// specified in the request, the Plugin SHALL take those into
	// consideration when calculating the minimum volume size of the
	// storage.
	//
	// This field is OPTIONAL. MUST NOT be negative.
	// The Plugin SHOULD provide a value for this field if it has
	// a maximum size for individual volumes and leave it unset
	// otherwise. COs MAY use it to make decision about
	// where to create volumes.
	MaximumVolumeSize *wrappers.Int64Value `protobuf:"bytes,2,opt,name=maximum_volume_size,json=maximumVolumeSize,proto3" json:"maximum_volume_size,omitempty"`
	// The smallest size that may be used in a
	// CreateVolumeRequest.capacity_range.limit_bytes field
	// to create a volume with the same parameters as those in
	// GetCapacityRequest.
	//
	// If `volume_capabilities` or `parameters` is
	// specified in the request, the Plugin SHALL take those into
	// consideration when calculating the maximum volume size of the
	// storage.
	//
	// This field is OPTIONAL. MUST NOT be negative.
	// The Plugin SHOULD provide a value for this field if it has
	// a minimum size for individual volumes and leave it unset
	// otherwise. COs MAY use it to make decision about
	// where to create volumes.
	MinimumVolumeSize    *wrappers.Int64Value `protobuf:"bytes,3,opt,name=minimum_volume_size,json=minimumVolumeSize,proto3" json:"minimum_volume_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *GetCapacityResponse) Reset()         { *m = GetCapacityResponse{} }
func (m *GetCapacityResponse) String() string { return proto.CompactTextString(m) }
func (*GetCapacityResponse) ProtoMessage()    {}
func (*GetCapacityResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{28}
}

func (m *GetCapacityResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetCapacityResponse.Unmarshal(m, b)
}
func (m *GetCapacityResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetCapacityResponse.Marshal(b, m, deterministic)
}
func (m *GetCapacityResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCapacityResponse.Merge(m, src)
}
func (m *GetCapacityResponse) XXX_Size() int {
	return xxx_messageInfo_GetCapacityResponse.Size(m)
}
func (m *GetCapacityResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCapacityResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetCapacityResponse proto.InternalMessageInfo

func (m *GetCapacityResponse) GetAvailableCapacity() int64 {
	if m != nil {
		return m.AvailableCapacity
	}
	return 0
}

func (m *GetCapacityResponse) GetMaximumVolumeSize() *wrappers.Int64Value {
	if m != nil {
		return m.MaximumVolumeSize
	}
	return nil
}

func (m *GetCapacityResponse) GetMinimumVolumeSize() *wrappers.Int64Value {
	if m != nil {
		return m.MinimumVolumeSize
	}
	return nil
}

type ControllerGetCapabilitiesRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ControllerGetCapabilitiesRequest) Reset()         { *m = ControllerGetCapabilitiesRequest{} }
func (m *ControllerGetCapabilitiesRequest) String() string { return proto.CompactTextString(m) }
func (*ControllerGetCapabilitiesRequest) ProtoMessage()    {}
func (*ControllerGetCapabilitiesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{29}
}

func (m *ControllerGetCapabilitiesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ControllerGetCapabilitiesRequest.Unmarshal(m, b)
}
func (m *ControllerGetCapabilitiesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ControllerGetCapabilitiesRequest.Marshal(b, m, deterministic)
}
func (m *ControllerGetCapabilitiesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControllerGetCapabilitiesRequest.Merge(m, src)
}
func (m *ControllerGetCapabilitiesRequest) XXX_Size() int {
	return xxx_messageInfo_ControllerGetCapabilitiesRequest.Size(m)
}
func (m *ControllerGetCapabilitiesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ControllerGetCapabilitiesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ControllerGetCapabilitiesRequest proto.InternalMessageInfo

type ControllerGetCapabilitiesResponse struct {
	// All the capabilities that the controller service supports. This
	// field is OPTIONAL.
	Capabilities         []*ControllerServiceCapability `protobuf:"bytes,1,rep,name=capabilities,proto3" json:"capabilities,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *ControllerGetCapabilitiesResponse) Reset()         { *m = ControllerGetCapabilitiesResponse{} }
func (m *ControllerGetCapabilitiesResponse) String() string { return proto.CompactTextString(m) }
func (*ControllerGetCapabilitiesResponse) ProtoMessage()    {}
func (*ControllerGetCapabilitiesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{30}
}

func (m *ControllerGetCapabilitiesResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ControllerGetCapabilitiesResponse.Unmarshal(m, b)
}
func (m *ControllerGetCapabilitiesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ControllerGetCapabilitiesResponse.Marshal(b, m, deterministic)
}
func (m *ControllerGetCapabilitiesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControllerGetCapabilitiesResponse.Merge(m, src)
}
func (m *ControllerGetCapabilitiesResponse) XXX_Size() int {
	return xxx_messageInfo_ControllerGetCapabilitiesResponse.Size(m)
}
func (m *ControllerGetCapabilitiesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ControllerGetCapabilitiesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ControllerGetCapabilitiesResponse proto.InternalMessageInfo

func (m *ControllerGetCapabilitiesResponse) GetCapabilities() []*ControllerServiceCapability {
	if m != nil {
		return m.Capabilities
	}
	return nil
}

// Specifies a capability of the controller service.
type ControllerServiceCapability struct {
	// Types that are valid to be assigned to Type:
	//
	//	*ControllerServiceCapability_Rpc
	Type                 isControllerServiceCapability_Type `protobuf_oneof:"type"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
	XXX_unrecognized     []byte                             `json:"-"`
	XXX_sizecache        int32                              `json:"-"`
}

func (m *ControllerServiceCapability) Reset()         { *m = ControllerServiceCapability{} }
func (m *ControllerServiceCapability) String() string { return proto.CompactTextString(m) }
func (*ControllerServiceCapability) ProtoMessage()    {}
func (*ControllerServiceCapability) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{31}
}

func (m *ControllerServiceCapability) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ControllerServiceCapability.Unmarshal(m, b)
}
func (m *ControllerServiceCapability) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ControllerServiceCapability.Marshal(b, m, deterministic)
}
func (m *ControllerServiceCapability) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControllerServiceCapability.Merge(m, src)
}
func (m *ControllerServiceCapability) XXX_Size() int {
	return xxx_messageInfo_ControllerServiceCapability.Size(m)
}
func (m *ControllerServiceCapability) XXX_DiscardUnknown() {
	xxx_messageInfo_ControllerServiceCapability.DiscardUnknown(m)
}

var xxx_messageInfo_ControllerServiceCapability proto.InternalMessageInfo

type isControllerServiceCapability_Type interface {
	isControllerServiceCapability_Type()
}

type ControllerServiceCapability_Rpc struct {
	Rpc *ControllerServiceCapability_RPC `protobuf:"bytes,1,opt,name=rpc,proto3,oneof"`
}

func (*ControllerServiceCapability_Rpc) isControllerServiceCapability_Type() {}

func (m *ControllerServiceCapability) GetType() isControllerServiceCapability_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *ControllerServiceCapability) GetRpc() *ControllerServiceCapability_RPC {
	if x, ok := m.GetType().(*ControllerServiceCapability_Rpc); ok {
		return x.Rpc
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ControllerServiceCapability) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ControllerServiceCapability_Rpc)(nil),
	}
}

type ControllerServiceCapability_RPC struct {
	Type                 ControllerServiceCapability_RPC_Type `protobuf:"varint,1,opt,name=type,proto3,enum=csi.v1.ControllerServiceCapability_RPC_Type" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                             `json:"-"`
	XXX_unrecognized     []byte                               `json:"-"`
	XXX_sizecache        int32                                `json:"-"`
}

func (m *ControllerServiceCapability_RPC) Reset()         { *m = ControllerServiceCapability_RPC{} }
func (m *ControllerServiceCapability_RPC) String() string { return proto.CompactTextString(m) }
func (*ControllerServiceCapability_RPC) ProtoMessage()    {}
func (*ControllerServiceCapability_RPC) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{31, 0}
}

func (m *ControllerServiceCapability_RPC) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ControllerServiceCapability_RPC.Unmarshal(m, b)
}
func (m *ControllerServiceCapability_RPC) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ControllerServiceCapability_RPC.Marshal(b, m, deterministic)
}
func (m *ControllerServiceCapability_RPC) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControllerServiceCapability_RPC.Merge(m, src)
}
func (m *ControllerServiceCapability_RPC) XXX_Size() int {
	return xxx_messageInfo_ControllerServiceCapability_RPC.Size(m)
}
func (m *ControllerServiceCapability_RPC) XXX_DiscardUnknown() {
	xxx_messageInfo_ControllerServiceCapability_RPC.DiscardUnknown(m)
}

var xxx_messageInfo_ControllerServiceCapability_RPC proto.InternalMessageInfo

func (m *ControllerServiceCapability_RPC) GetType() ControllerServiceCapability_RPC_Type {
	if m != nil {
		return m.Type
	}
	return ControllerServiceCapability_RPC_UNKNOWN
}

type CreateSnapshotRequest struct {
	// The ID of the source volume to be snapshotted.
	// This field is REQUIRED.
	SourceVolumeId string `protobuf:"bytes,1,opt,name=source_volume_id,json=sourceVolumeId,proto3" json:"source_volume_id,omitempty"`
	// The suggested name for the snapshot. This field is REQUIRED for
	// idempotency.
	// Any Unicode string that conforms to the length limit is allowed
	// except those containing the following banned characters:
	// U+0000-U+0008, U+000B, U+000C, U+000E-U+001F, U+007F-U+009F.
	// (These are control characters other than commonly used whitespace.)
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Secrets required by plugin to complete snapshot creation request.
	// This field is OPTIONAL. Refer to the `Secrets Requirements`
	// section on how to use this field.
	Secrets map[string]string `protobuf:"bytes,3,rep,name=secrets,proto3" json:"secrets,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Plugin specific parameters passed in as opaque key-value pairs.
	// This field is OPTIONAL. The Plugin is responsible for parsing and
	// validating these parameters. COs will treat these as opaque.
	// Use cases for opaque parameters:
	//   - Specify a policy to automatically clean up the snapshot.
	//   - Specify an expiration date for the snapshot.
	//   - Specify whether the snapshot is readonly or read/write.
	//   - Specify if the snapshot should be replicated to some place.
	//   - Specify primary or secondary for replication systems that
	//     support snapshotting only on primary.
	Parameters           map[string]string `protobuf:"bytes,4,rep,name=parameters,proto3" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *CreateSnapshotRequest) Reset()         { *m = CreateSnapshotRequest{} }
func (m *CreateSnapshotRequest) String() string { return proto.CompactTextString(m) }
func (*CreateSnapshotRequest) ProtoMessage()    {}
func (*CreateSnapshotRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{32}
}

func (m *CreateSnapshotRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CreateSnapshotRequest.Unmarshal(m, b)
}
func (m *CreateSnapshotRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CreateSnapshotRequest.Marshal(b, m, deterministic)
}
func (m *CreateSnapshotRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSnapshotRequest.Merge(m, src)
}
func (m *CreateSnapshotRequest) XXX_Size() int {
	return xxx_messageInfo_CreateSnapshotRequest.Size(m)
}
func (m *CreateSnapshotRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSnapshotRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSnapshotRequest proto.InternalMessageInfo

func (m *CreateSnapshotRequest) GetSourceVolumeId() string {
	if m != nil {
		return m.SourceVolumeId
	}
	return ""
}

func (m *CreateSnapshotRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateSnapshotRequest) GetSecrets() map[string]string {
	if m != nil {
		return m.Secrets
	}
	return nil
}

func (m *CreateSnapshotRequest) GetParameters() map[string]string {
	if m != nil {
		return m.Parameters
	}
	return nil
}

type CreateSnapshotResponse struct {
	// Contains all attributes of the newly created snapshot that are
	// relevant to the CO along with information required by the Plugin
	// to uniquely identify the snapshot. This field is REQUIRED.
	Snapshot             *Snapshot `protobuf:"bytes,1,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *CreateSnapshotResponse) Reset()         { *m = CreateSnapshotResponse{} }
func (m *CreateSnapshotResponse) String() string { return proto.CompactTextString(m) }
func (*CreateSnapshotResponse) ProtoMessage()    {}
func (*CreateSnapshotResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{33}
}

func (m *CreateSnapshotResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CreateSnapshotResponse.Unmarshal(m, b)
}
func (m *CreateSnapshotResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CreateSnapshotResponse.Marshal(b, m, deterministic)
}
func (m *CreateSnapshotResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSnapshotResponse.Merge(m, src)
}
func (m *CreateSnapshotResponse) XXX_Size() int {
	return xxx_messageInfo_CreateSnapshotResponse.Size(m)
}
func (m *CreateSnapshotResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSnapshotResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSnapshotResponse proto.InternalMessageInfo

func (m *CreateSnapshotResponse) GetSnapshot() *Snapshot {
	if m != nil {
		return m.Snapshot
	}
	return nil
}

// Information about a specific snapshot.
type Snapshot struct {
	// This is the complete size of the snapshot in bytes. The purpose of
	// this field is to give CO guidance on how much space is needed to
	// create a volume from this snapshot. The size of the volume MUST NOT
	// be less than the size of the source snapshot. This field is
	// OPTIONAL. If this field is not set, it indicates that this size is
	// unknown. The value of this field MUST NOT be negative and a size of
	// zero means it is unspecified.
	SizeBytes int64 `protobuf:"varint,1,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	// The identifier for this snapshot, generated by the plugin.
	// This field is REQUIRED.
	// This field MUST contain enough information to uniquely identify
	// this specific snapshot vs all other snapshots supported by this
	// plugin.
	// This field SHALL be used by the CO in subsequent calls to refer to
	// this snapshot.
	// The SP is NOT responsible for global uniqueness of snapshot_id
	// across multiple SPs.
	SnapshotId string `protobuf:"bytes,2,opt,name=snapshot_id,json=snapshotId,proto3" json:"snapshot_id,omitempty"`
	// Identity information for the source volume. Note that creating a
	// snapshot from a snapshot is not supported here so the source has to
	// be a volume. This field is REQUIRED.
	SourceVolumeId string `protobuf:"bytes,3,opt,name=source_volume_id,json=sourceVolumeId,proto3" json:"source_volume_id,omitempty"`
	// Timestamp when the point-in-time snapshot is taken on the storage
	// system. This field is REQUIRED.
	CreationTime *timestamp.Timestamp `protobuf:"bytes,4,opt,name=creation_time,json=creationTime,proto3" json:"creation_time,omitempty"`
	// Indicates if a snapshot is ready to use as a
	// `volume_content_source` in a `CreateVolumeRequest`. The default
	// value is false. This field is REQUIRED.
	ReadyToUse bool `protobuf:"varint,5,opt,name=ready_to_use,json=readyToUse,proto3" json:"ready_to_use,omitempty"`
	// The ID of the volume group snapshot that this snapshot is part of.
	// It uniquely identifies the group snapshot on the storage system.
	// This field is OPTIONAL.
	// If this snapshot is a member of a volume group snapshot, and it
	// MUST NOT be deleted as a stand alone snapshot, then the SP
	// MUST provide the ID of the volume group snapshot in this field.
	// If provided, CO MUST use this field in subsequent volume group
	// snapshot operations to indicate that this snapshot is part of the
	// specified group snapshot.
	// If not provided, CO SHALL treat the snapshot as independent,
	// and SP SHALL allow it to be deleted separately.
	// If this message is inside a VolumeGroupSnapshot message, the value
	// MUST be the same as the group_snapshot_id in that message.
	GroupSnapshotId      string   `protobuf:"bytes,6,opt,name=group_snapshot_id,json=groupSnapshotId,proto3" json:"group_snapshot_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Snapshot) Reset()         { *m = Snapshot{} }
func (m *Snapshot) String() string { return proto.CompactTextString(m) }
func (*Snapshot) ProtoMessage()    {}
func (*Snapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{34}
}

func (m *Snapshot) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Snapshot.Unmarshal(m, b)
}
func (m *Snapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Snapshot.Marshal(b, m, deterministic)
}
func (m *Snapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Snapshot.Merge(m, src)
}
func (m *Snapshot) XXX_Size() int {
	return xxx_messageInfo_Snapshot.Size(m)
}
func (m *Snapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_Snapshot.DiscardUnknown(m)
}

var xxx_messageInfo_Snapshot proto.InternalMessageInfo

func (m *Snapshot) GetSizeBytes() int64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

func (m *Snapshot) GetSnapshotId() string {
	if m != nil {
		return m.SnapshotId
	}
	return ""
}

func (m *Snapshot) GetSourceVolumeId() string {
	if m != nil {
		return m.SourceVolumeId
	}
	return ""
}

func (m *Snapshot) GetCreationTime() *timestamp.Timestamp {
	if m != nil {
		return m.CreationTime
	}
	return nil
}

func (m *Snapshot) GetReadyToUse() bool {
	if m != nil {
		return m.ReadyToUse
	}
	return false
}

func (m *Snapshot) GetGroupSnapshotId() string {
	if m != nil {
		return m.GroupSnapshotId
	}
	return ""
}

type DeleteSnapshotRequest struct {
	// The ID of the snapshot to be deleted.
	// This field is REQUIRED.
	SnapshotId string `protobuf:"bytes,1,opt,name=snapshot_id,json=snapshotId,proto3" json:"snapshot_id,omitempty"`
	// Secrets required by plugin to complete snapshot deletion request.
	// This field is OPTIONAL. Refer to the `Secrets Requirements`
	// section on how to use this field.
	Secrets              map[string]string `protobuf:"bytes,2,rep,name=secrets,proto3" json:"secrets,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *DeleteSnapshotRequest) Reset()         { *m = DeleteSnapshotRequest{} }
func (m *DeleteSnapshotRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteSnapshotRequest) ProtoMessage()    {}
func (*DeleteSnapshotRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{35}
}

func (m *DeleteSnapshotRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DeleteSnapshotRequest.Unmarshal(m, b)
}
func (m *DeleteSnapshotRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DeleteSnapshotRequest.Marshal(b, m, deterministic)
}
func (m *DeleteSnapshotRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteSnapshotRequest.Merge(m, src)
}
func (m *DeleteSnapshotRequest) XXX_Size() int {
	return xxx_messageInfo_DeleteSnapshotRequest.Size(m)
}
func (m *DeleteSnapshotRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteSnapshotRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteSnapshotRequest proto.InternalMessageInfo

func (m *DeleteSnapshotRequest) GetSnapshotId() string {
	if m != nil {
		return m.SnapshotId
	}
	return ""
}

func (m *DeleteSnapshotRequest) GetSecrets() map[string]string {
	if m != nil {
		return m.Secrets
	}
	return nil
}

type DeleteSnapshotResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteSnapshotResponse) Reset()         { *m = DeleteSnapshotResponse{} }
func (m *DeleteSnapshotResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteSnapshotResponse) ProtoMessage()    {}
func (*DeleteSnapshotResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{36}
}

func (m *DeleteSnapshotResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DeleteSnapshotResponse.Unmarshal(m, b)
}
func (m *DeleteSnapshotResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DeleteSnapshotResponse.Marshal(b, m, deterministic)
}
func (m *DeleteSnapshotResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteSnapshotResponse.Merge(m, src)
}
func (m *DeleteSnapshotResponse) XXX_Size() int {
	return xxx_messageInfo_DeleteSnapshotResponse.Size(m)
}
func (m *DeleteSnapshotResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteSnapshotResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteSnapshotResponse proto.InternalMessageInfo

// List all snapshots on the storage system regardless of how they were
// created.
type ListSnapshotsRequest struct {
	// If specified (non-zero value), the Plugin MUST NOT return more
	// entries than this number in the response. If the actual number of
	// entries is more than this number, the Plugin MUST set `next_token`
	// in the response which can be used to get the next page of entries
	// in the subsequent `ListSnapshots` call. This field is OPTIONAL. If
	// not specified (zero value), it means there is no restriction on the
	// number of entries that can be returned.
	// The value of this field MUST NOT be negative.
	MaxEntries int32 `protobuf:"varint,1,opt,name=max_entries,json=maxEntries,proto3" json:"max_entries,omitempty"`
	// A token to specify where to start paginating. Set this field to
	// `next_token` returned by a previous `ListSnapshots` call to get the
	// next page of entries. This field is OPTIONAL.
	// An empty string is equal to an unspecified field value.
	StartingToken string `protobuf:"bytes,2,opt,name=starting_token,json=startingToken,proto3" json:"starting_token,omitempty"`
	// Identity information for the source volume. This field is OPTIONAL.
	// It can be used to list snapshots by volume.
	SourceVolumeId string `protobuf:"bytes,3,opt,name=source_volume_id,json=sourceVolumeId,proto3" json:"source_volume_id,omitempty"`
	// Identity information for a specific snapshot. This field is
	// OPTIONAL. It can be used to list only a specific snapshot.
	// ListSnapshots will return with current snapshot information
	// and will not block if the snapshot is being processed after
	// it is cut.
	SnapshotId string `protobuf:"bytes,4,opt,name=snapshot_id,json=snapshotId,proto3" json:"snapshot_id,omitempty"`
	// Secrets required by plugin to complete ListSnapshot request.
	// This field is OPTIONAL. Refer to the `Secrets Requirements`
	// section on how to use this field.
	Secrets              map[string]string `protobuf:"bytes,5,rep,name=secrets,proto3" json:"secrets,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ListSnapshotsRequest) Reset()         { *m = ListSnapshotsRequest{} }
func (m *ListSnapshotsRequest) String() string { return proto.CompactTextString(m) }
func (*ListSnapshotsRequest) ProtoMessage()    {}
func (*ListSnapshotsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{37}
}

func (m *ListSnapshotsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListSnapshotsRequest.Unmarshal(m, b)
}
func (m *ListSnapshotsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListSnapshotsRequest.Marshal(b, m, deterministic)
}
func (m *ListSnapshotsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListSnapshotsRequest.Merge(m, src)
}
func (m *ListSnapshotsRequest) XXX_Size() int {
	return xxx_messageInfo_ListSnapshotsRequest.Size(m)
}
func (m *ListSnapshotsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListSnapshotsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListSnapshotsRequest proto.InternalMessageInfo

func (m *ListSnapshotsRequest) GetMaxEntries() int32 {
	if m != nil {
		return m.MaxEntries
	}
	return 0
}

func (m *ListSnapshotsRequest) GetStartingToken() string {
	if m != nil {
		return m.StartingToken
	}
	return ""
}

func (m *ListSnapshotsRequest) GetSourceVolumeId() string {
	if m != nil {
		return m.SourceVolumeId
	}
	return ""
}

func (m *ListSnapshotsRequest) GetSnapshotId() string {
	if m != nil {
		return m.SnapshotId
	}
	return ""
}

func (m *ListSnapshotsRequest) GetSecrets() map[string]string {
	if m != nil {
		return m.Secrets
	}
	return nil
}

type ListSnapshotsResponse struct {
	Entries []*ListSnapshotsResponse_Entry `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty"`
	// This token allows you to get the next page of entries for
	// `ListSnapshots` request. If the number of entries is larger than
	// `max_entries`, use the `next_token` as a value for the
	// `starting_token` field in the next `ListSnapshots` request. This
	// field is OPTIONAL.
	// An empty string is equal to an unspecified field value.
	NextToken            string   `protobuf:"bytes,2,opt,name=next_token,json=nextToken,proto3" json:"next_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListSnapshotsResponse) Reset()         { *m = ListSnapshotsResponse{} }
func (m *ListSnapshotsResponse) String() string { return proto.CompactTextString(m) }
func (*ListSnapshotsResponse) ProtoMessage()    {}
func (*ListSnapshotsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{38}
}

func (m *ListSnapshotsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListSnapshotsResponse.Unmarshal(m, b)
}
func (m *ListSnapshotsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListSnapshotsResponse.Marshal(b, m, deterministic)
}
func (m *ListSnapshotsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListSnapshotsResponse.Merge(m, src)
}
func (m *ListSnapshotsResponse) XXX_Size() int {
	return xxx_messageInfo_ListSnapshotsResponse.Size(m)
}
func (m *ListSnapshotsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListSnapshotsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListSnapshotsResponse proto.InternalMessageInfo

func (m *ListSnapshotsResponse) GetEntries() []*ListSnapshotsResponse_Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

func (m *ListSnapshotsResponse) GetNextToken() string {
	if m != nil {
		return m.NextToken
	}
	return ""
}

type ListSnapshotsResponse_Entry struct {
	Snapshot             *Snapshot `protobuf:"bytes,1,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ListSnapshotsResponse_Entry) Reset()         { *m = ListSnapshotsResponse_Entry{} }
func (m *ListSnapshotsResponse_Entry) String() string { return proto.CompactTextString(m) }
func (*ListSnapshotsResponse_Entry) ProtoMessage()    {}
func (*ListSnapshotsResponse_Entry) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{38, 0}
}

func (m *ListSnapshotsResponse_Entry) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListSnapshotsResponse_Entry.Unmarshal(m, b)
}
func (m *ListSnapshotsResponse_Entry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListSnapshotsResponse_Entry.Marshal(b, m, deterministic)
}
func (m *ListSnapshotsResponse_Entry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListSnapshotsResponse_Entry.Merge(m, src)
}
func (m *ListSnapshotsResponse_Entry) XXX_Size() int {
	return xxx_messageInfo_ListSnapshotsResponse_Entry.Size(m)
}
func (m *ListSnapshotsResponse_Entry) XXX_DiscardUnknown() {
	xxx_messageInfo_ListSnapshotsResponse_Entry.DiscardUnknown(m)
}

var xxx_messageInfo_ListSnapshotsResponse_Entry proto.InternalMessageInfo

func (m *ListSnapshotsResponse_Entry) GetSnapshot() *Snapshot {
	if m != nil {
		return m.Snapshot
	}
	return nil
}

type ControllerExpandVolumeRequest struct {
	// The ID of the volume to expand. This field is REQUIRED.
	VolumeId string `protobuf:"bytes,1,opt,name=volume_id,json=volumeId,proto3" json:"volume_id,omitempty"`
	// This allows CO to specify the capacity requirements of the volume
	// after expansion. This field is REQUIRED.
	CapacityRange *CapacityRange `protobuf:"bytes,2,opt,name=capacity_range,json=capacityRange,proto3" json:"capacity_range,omitempty"`
	// Secrets required by the plugin for expanding the volume.
	// This field is OPTIONAL.
	Secrets map[string]string `protobuf:"bytes,3,rep,name=secrets,proto3" json:"secrets,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Volume capability describing how the CO intends to use this volume.
	// This allows SP to determine if volume is being used as a block
	// device or mounted file system. For example - if volume is
	// being used as a block device - the SP MAY set
	// node_expansion_required to false in ControllerExpandVolumeResponse
	// to skip invocation of NodeExpandVolume on the node by the CO.
	// This is an OPTIONAL field.
	VolumeCapability     *VolumeCapability `protobuf:"bytes,4,opt,name=volume_capability,json=volumeCapability,proto3" json:"volume_capability,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ControllerExpandVolumeRequest) Reset()         { *m = ControllerExpandVolumeRequest{} }
func (m *ControllerExpandVolumeRequest) String() string { return proto.CompactTextString(m) }
func (*ControllerExpandVolumeRequest) ProtoMessage()    {}
func (*ControllerExpandVolumeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{39}
}

func (m *ControllerExpandVolumeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ControllerExpandVolumeRequest.Unmarshal(m, b)
}
func (m *ControllerExpandVolumeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ControllerExpandVolumeRequest.Marshal(b, m, deterministic)
}
func (m *ControllerExpandVolumeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControllerExpandVolumeRequest.Merge(m, src)
}
func (m *ControllerExpandVolumeRequest) XXX_Size() int {
	return xxx_messageInfo_ControllerExpandVolumeRequest.Size(m)
}
func (m *ControllerExpandVolumeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ControllerExpandVolumeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ControllerExpandVolumeRequest proto.InternalMessageInfo

func (m *ControllerExpandVolumeRequest) GetVolumeId() string {
	if m != nil {
		return m.VolumeId
	}
	return ""
}

func (m *ControllerExpandVolumeRequest) GetCapacityRange() *CapacityRange {
	if m != nil {
		return m.CapacityRange
	}
	return nil
}

func (m *ControllerExpandVolumeRequest) GetSecrets() map[string]string {
	if m != nil {
		return m.Secrets
	}
	return nil
}

func (m *ControllerExpandVolumeRequest) GetVolumeCapability() *VolumeCapability {
	if m != nil {
		return m.VolumeCapability
	}
	return nil
}

type ControllerExpandVolumeResponse struct {
	// Capacity of volume after expansion. This field is REQUIRED.
	CapacityBytes int64 `protobuf:"varint,1,opt,name=capacity_bytes,json=capacityBytes,proto3" json:"capacity_bytes,omitempty"`
	// Whether node expansion is required for the volume. When true
	// the CO MUST make NodeExpandVolume RPC call on the node. This field
	// is REQUIRED.
	NodeExpansionRequired bool     `protobuf:"varint,2,opt,name=node_expansion_required,json=nodeExpansionRequired,proto3" json:"node_expansion_required,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *ControllerExpandVolumeResponse) Reset()         { *m = ControllerExpandVolumeResponse{} }
func (m *ControllerExpandVolumeResponse) String() string { return proto.CompactTextString(m) }
func (*ControllerExpandVolumeResponse) ProtoMessage()    {}
func (*ControllerExpandVolumeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9cdb00adce470e01, []int{40}
}

func (m *ControllerExpandVolumeResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ControllerExpandVolumeResponse.Unmarshal(m, b)
}
func (m *ControllerExpandVolumeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ControllerExpandVolumeResponse.Marshal(b, m, deterministic)
}
func (m *ControllerExpandVolumeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControllerExpandVolumeResponse.Merge(m, src)
}
func (m *ControllerExpandVolumeResponse) XXX_Size() int {
	return xxx_messageInfo_ControllerExpandVolumeResponse.Size(m)
}
func (m *ControllerExpandVolumeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ControllerExpandVolumeResponse.DiscardUnknown(m)
}